<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C64 Full Screen Simulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
    :root {
        --c64-blue: #352879;
        --c64-lightblue: #706deb;
        --c64-cyan: #6cffee;
        --c64-border: #706deb;
    }

    html, body {
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        image-rendering: pixelated;
    }

    .tv {
        width: 96vw;
        height: 96vh;
        max-width: 1400px;
        border: 20px solid var(--c64-border);
        border-radius: 30px;
        box-shadow:
            0 0 30px rgba(0,0,0,0.9),
            inset 0 0 40px rgba(0,0,0,0.6);
        background: var(--c64-blue);
        padding: 2vh 2vw;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
    }

    #screen {
        flex: 1;
        display: grid;
        grid-template-rows: repeat(25, 1fr);
        grid-template-columns: repeat(40, 1fr);
        background: var(--c64-blue);
        color: var(--c64-cyan);
        font-family: 'C64', monospace;
        font-size: clamp(12px, 2.2vh, 36px);
        line-height: 1;
        padding: 1vh 1vw;
        box-sizing: border-box;
    }

    .line {
        grid-column: 1 / -1;
        white-space: pre;
        overflow: hidden;
    }

    .double-wide {
        display: inline-block;
        transform: scaleX(2);
        transform-origin: left center;
    }

    .prompt { margin-right: 0.5ch; }

    #input-line {
        display: flex;
        align-items: center;
    }

    #command-input {
        background: transparent;
        border: none;
        outline: none;
        color: transparent;
        caret-color: transparent;
        font-family: 'C64', monospace;
        font-size: inherit;
        position: absolute;
        left: -9999px;
    }

    .cursor {
        display: inline-block;
        width: 1ch;
        background: var(--c64-cyan);
        animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink { to { visibility: hidden; } }

</style>
</head>

<body>
<div class="tv">
    <div id="screen"></div>
</div>

<script>
/* ==================================================
   GLOBALS
================================================== */
let echo = true;


let cursorX = 0;
let cursorY = 0;

let inputMode = null;
let currentFG = "#6cffee";     // default C64 cyan
let currentBG = "#352879";     // default C64 blue background


const screen = document.getElementById("screen");
const lines = [];

function ECHOOFF(){
    echo = false;
}
function ECHOON(){
    echo = true;
}

function ASCIIART(str) {
    // normalize newlines
    str = str.replace(/\r/g, "");

    // strip leading/trailing blank lines
    str = str.replace(/^\s*\n+/, "").replace(/\n+\s*$/, "");

    // split into lines
    const lines = str.split("\n");

    // compute minimum indentation (in spaces/tabs) of non-empty lines
    let minIndent = Infinity;
    for (const ln of lines) {
    if (!ln.trim()) continue;
    const m = ln.match(/^[ \t]*/)[0].length;
    if (m < minIndent) minIndent = m;
    }
    if (!isFinite(minIndent)) minIndent = 0;

    // remove that indentation from every line, then join without separators
    return lines.map(l => l.slice(minIndent)).join("");
}
/* ==================================================
   BUILD 24 ROWS + INPUT LINE
================================================== */
function makeRow() {
    const d = document.createElement("div");
    d.className = "line";
    return d;
}

for (let i = 0; i < 24; i++) {
    const row = makeRow();
    screen.appendChild(row);
    lines.push(row);
}

const inputLine = makeRow();
inputLine.id = "input-line";
inputLine.innerHTML =
    `<span class="double-wide prompt">></span>
     <span id="input-text"></span>
     <span class="cursor"> </span>`;
screen.appendChild(inputLine);
lines.push(inputLine);

const inputText = document.getElementById("input-text");

const commandInput = document.createElement("input");
commandInput.type = "text";
commandInput.id = "command-input";
document.body.appendChild(commandInput);

/* ==================================================
   UTILITY FUNCTIONS
================================================== */
function wide(text) {
    const span = document.createElement("span");
    span.className = "double-wide";
    span.textContent = text;
    return span;
}

function nextLine() {
    cursorX = 0;
    cursorY++;
    if (cursorY > 23) {
        const removed = lines.shift();
        if (removed !== inputLine) screen.removeChild(removed);
        const newRow = makeRow();
        screen.insertBefore(newRow, inputLine);
        lines.splice(23, 0, newRow);
        cursorY = 23;
    }
}

function LOCATE(x, y) {
    cursorX = Math.max(0, Math.min(39, parseInt(x)));
    cursorY = Math.max(0, Math.min(23, parseInt(y)));
}

function getColor(n) {
    const table = {
        0:"#000000", 1:"#ffffff", 2:"#808080", 3:"#b0c4de",
        4:"#a9a9a9", 7:"#c0c0c0", 8:"#dda0dd", 9:"#ee82ee",
        10:"#ff0000", 11:"#ffa500", 12:"#ffff00", 13:"#008000",
        14:"#0000ff", 15:"#4b0082", 16:"#ee82ee"
    };
    return table[n] || "#ffffff";
}

function COLOR(fg, bg) {
    if (fg !== undefined) currentFG = getColor(parseInt(fg));
    if (bg !== undefined) currentBG = getColor(parseInt(bg));
}

function echoCommand(cmd) {
    const row = lines[cursorY];
    row.innerHTML = "";
    const wrap = document.createElement("span");
    wrap.className = "double-wide";

    const promptSpan = document.createElement("span");
    promptSpan.textContent = ">";
    wrap.appendChild(promptSpan);

    const textSpan = document.createElement("span");
    textSpan.textContent = cmd;
    wrap.appendChild(textSpan);

    row.appendChild(wrap);
    nextLine();
}

/* ==================================================
   PRINT WITH WRAPPING + COLORS + ONE DOUBLE-WIDE WRAPPER
================================================== */
function PRINT(text = "") {
    text = String(text);
    let idx = 0;

    while (idx < text.length) {

        const row = lines[cursorY];

        let current = row.textContent || "";
        current = current.padEnd(40, " ");
        let arr = current.split("");

        let space = 40 - cursorX;
        let chunk = text.substring(idx, idx + space);

        let cellSpans = [];

        for (let ch of arr) {
            const inner = document.createElement("span");
            inner.textContent = ch;
            cellSpans.push(inner);
        }

        for (let i = 0; i < chunk.length; i++) {
            const inner = document.createElement("span");
            inner.textContent = chunk[i];
            inner.style.color = currentFG;
            inner.style.backgroundColor = currentBG;
            cellSpans[cursorX + i] = inner;
        }

        row.innerHTML = "";
        const wrap = document.createElement("span");
        wrap.className = "double-wide";

        cellSpans.forEach(s => wrap.appendChild(s));
        row.appendChild(wrap);

        cursorX += chunk.length;
        idx += chunk.length;

        if (cursorX >= 40) nextLine();
    }

    nextLine();
}

/* ==================================================
   REAL INPUT()
================================================== */
commandInput.addEventListener("input", () => {
    inputText.textContent = commandInput.value;
});

function INPUT(promptText = "") {
    return new Promise(resolve => {

        if (promptText)
            PRINT(promptText);

        commandInput.value = "";
        inputText.textContent = "";

        inputMode = resolve;

        commandInput.focus();
    });
}

/* ==================================================
   MAIN KEYDOWN HANDLER
================================================== */
commandInput.addEventListener("keydown", async (e) => {

    if (e.key !== "Enter") return;

    const typed = commandInput.value.trim();

    if (inputMode) {
        if(echo) {
            echoCommand(typed);
        }
        const resolver = inputMode;
        inputMode = null;
        commandInput.value = "";
        inputText.textContent = "";
        resolver(typed);
        return;
    }

    if (typed === "") {
        commandInput.value = "";
        inputText.textContent = "";
        return;
    }
    if(echo) {
        echoCommand(typed);
    }

    commandInput.value = "";
    inputText.textContent = "";

    try {
        let result = await eval(`(async()=>{ ${typed} })()`);
        if (result !== undefined) PRINT(result);
    } catch (err) {
        PRINT("?SYNTAX  ERROR:"+err);
    }

    PRINT("READY.");
    commandInput.focus();
});

/* ==================================================
   BOOT SCREEN
================================================== */
LOCATE(0,0);
PRINT("**** JPLY 64 JS_BASIC V1 ****");
PRINT("");
PRINT("64K RAM SYSTEM  38911 BASIC BYTES FREE");
PRINT("");
PRINT("READY.");
for (let i = 0; i < 17; i++) PRINT("");

document.addEventListener("click", () => commandInput.focus());
commandInput.focus();
/*
test input and locate 

ECHOOFF();
PRINT("ENTER NAME:");
A =INPUT();
PRINT("HELLO " + A);
AGE = INPUT("AGE?");
PRINT("YOU ARE " + AGE + " YEARS OLD");
LOCATE(5,5);
PRINT("HELLO");
LOCATE(5,5);
PRINT("A");

test UTF8ART art

ECHOOFF();
COLOR(0,10);LOCATE(0,0);
JPLYBBS =  '';
JPLYBBS += '⣟⣙⣿⡟⠛⠛⠛⠛⠻⠿⠟⠙⠚⠑⠏⢻⣙⣛⠊⠳⠛⠛⠛⢛⡑⠞⠿⠿⢛⡗⣋⣛⠿⠿⠻⠹⠚⡓⣋⣻';
JPLYBBS += '⡿⡿⣹⠧⢸⠉⠉⠉⣷⡏⠉⠉⠉⠉⠉⠿⠭⠩⢸⠉⠉⠉⢹⣮⠇⣿⠉⠩⠧⡵⠇⣯⢸⠉⠉⢹⣏⢷⡟⣿';
JPLYBBS += '⠧⠯⠥⠄⢸⠀⠀⠀⣿⡇⠀⠀⠀⣀⠀⠀⠀⠉⣾⠀⠀⠀⢸⣿⣷⣿⡀⠀⠀⠉⣶⣸⠉⠀⠀⢸⣿⣿⣭⠭';
JPLYBBS += '⣚⣿⢻⡏⢸⠀⠀⠀⣿⡇⠀⠀⠀⠿⠒⠀⠀⠀⣿⠀⠀⠀⢸⣿⣿⣿⣧⢠⠀⠀⠉⠉⠀⢠⠀⣿⣿⣿⣿⣿';
JPLYBBS += '⡊⣿⠛⠛⠚⠀⠀⠀⣿⡇⠀⠀⠀⣀⣀⣀⣤⣷⣿⠀⠀⠀⠘⠛⠛⠛⢻⣼⡶⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣧';
JPLYBBS += '⡅⣿⡀⠀⠀⠀⠀⣤⣿⡇⠀⠀⢀⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⠏⡋⢙⡇⠀⡇⣿⣿⣿⣧⣇⡇⢸⣿⣿⣿⡟⣿⢹⡀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡇⢸⢸⣿⣿⣿⠿⠿⠿⠟';
JPLYBBS += '⡛⣽⣿⣷⡂⣓⣿⣿⡏⠉⠉⠁⠈⠉⠙⠿⡍⣿⠉⠉⠉⠉⠉⠙⠛⢿⣿⣿⡿⠉⠀⠀⠈⠉⠙⢯⢩⡍⣥⣭';
JPLYBBS += '⢟⣙⢛⣛⣛⣛⣛⣛⡇⠀⠀⢠⣤⡄⠀⠀⠀⣿⠀⠀⠀⣤⣤⠀⠀⠀⢸⠀⠀⠀⣤⣶⣤⡀⣶⣿⣿⣖⣧⣿';
JPLYBBS += '⣭⣿⣿⣿⣷⣷⢿⣿⡇⠀⠀⠈⠉⠁⠀⣤⣿⣿⠀⠀⠀⠉⠉⠀⢠⣾⣿⠀⠀⠀⠈⠉⠉⠿⢿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⢿⣿⣿⣏⣿⣿⢿⡇⠀⠀⢰⣶⡆⠀⠀⠉⣿⠀⠀⠀⣶⣶⠀⠀⠀⢹⣶⡇⣄⣀⣀⡀⠀⠀⢸⣿⣻⣿⣿';
JPLYBBS += '⣼⣶⣚⣻⣿⣷⣯⣶⡇⠀⠀⠈⠉⠁⠀⠀⣠⣿⠀⠀⠀⠉⠉⠀⠀⢀⣸⣿⠛⠉⠛⠛⠃⠀⠀⣸⣿⣿⣟⣛';
JPLYBBS += '⠭⣶⣶⣖⡶⠶⡖⣲⡇⣤⠀⣤⣤⣤⣴⣿⣿⣿⠀⣤⠀⣤⣤⣤⣼⣿⣿⣁⡄⠀⡀⢀⡀⣄⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⢩⣭⠽⡿⠿⠿⣿⡇⠸⠀⣿⣿⣿⣿⣿⣿⣿⠶⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⠀⠃⢸⣷⣿⣿⣿⣿⡿⣏⣿';
JPLYBBS += '⣿⣿⣿⣧⣿⣷⣷⣿⣽⠍⠀⣯⣿⣿⣯⢿⠿⡿⣾⠍⠀⢽⣿⢿⠿⢽⣿⣿⠿⠿⠇⢸⣿⣿⣿⣿⣿⣿⡿⣿';
JPLYBBS += '⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣿⣿⣿⣿⣾⡿⣿⣿⢿⠀⣿⣿⣿⣿⣿⣿⣿⢿⣿⡇⢸⣿⣾⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣯⣿⣷⣶⣶⣿⣿⣾⣾⣿⣿⣿⣿⣶⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿';
PRINT(JPLYBBS);

ECHOOFF();
COLOR(0,10);LOCATE(0,0);
JPLYBBS = "⣟⣙⣿⡟⠛⠛⠛⠛⠻⠿⠟⠙⠚⠑⠏⢻⣙⣛⠊⠳⠛⠛⠛⢛⡑⠞⠿⠿⢛⡗⣋⣛⠿⠿⠻⠹⠚⡓⣋⣻⡿⡿⣹⠧⢸⠉⠉⠉⣷⡏⠉⠉⠉⠉⠉⠿⠭⠩⢸⠉⠉⠉⢹⣮⠇⣿⠉⠩⠧⡵⠇⣯⢸⠉⠉⢹⣏⢷⡟⣿⠧⠯⠥⠄⢸⠀⠀⠀⣿⡇⠀⠀⠀⣀⠀⠀⠀⠉⣾⠀⠀⠀⢸⣿⣷⣿⡀⠀⠀⠉⣶⣸⠉⠀⠀⢸⣿⣿⣭⠭⣚⣿⢻⡏⢸⠀⠀⠀⣿⡇⠀⠀⠀⠿⠒⠀⠀⠀⣿⠀⠀⠀⢸⣿⣿⣿⣧⢠⠀⠀⠉⠉⠀⢠⠀⣿⣿⣿⣿⣿⡊⣿⠛⠛⠚⠀⠀⠀⣿⡇⠀⠀⠀⣀⣀⣀⣤⣷⣿⠀⠀⠀⠘⠛⠛⠛⢻⣼⡶⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣧⡅⣿⡀⠀⠀⠀⠀⣤⣿⡇⠀⠀⢀⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣿⠏⡋⢙⡇⠀⡇⣿⣿⣿⣧⣇⡇⢸⣿⣿⣿⡟⣿⢹⡀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡇⢸⢸⣿⣿⣿⠿⠿⠿⠟⡛⣽⣿⣷⡂⣓⣿⣿⡏⠉⠉⠁⠈⠉⠙⠿⡍⣿⠉⠉⠉⠉⠉⠙⠛⢿⣿⣿⡿⠉⠀⠀⠈⠉⠙⢯⢩⡍⣥⣭⢟⣙⢛⣛⣛⣛⣛⣛⡇⠀⠀⢠⣤⡄⠀⠀⠀⣿⠀⠀⠀⣤⣤⠀⠀⠀⢸⠀⠀⠀⣤⣶⣤⡀⣶⣿⣿⣖⣧⣿⣭⣿⣿⣿⣷⣷⢿⣿⡇⠀⠀⠈⠉⠁⠀⣤⣿⣿⠀⠀⠀⠉⠉⠀⢠⣾⣿⠀⠀⠀⠈⠉⠉⠿⢿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣏⣿⣿⢿⡇⠀⠀⢰⣶⡆⠀⠀⠉⣿⠀⠀⠀⣶⣶⠀⠀⠀⢹⣶⡇⣄⣀⣀⡀⠀⠀⢸⣿⣻⣿⣿⣼⣶⣚⣻⣿⣷⣯⣶⡇⠀⠀⠈⠉⠁⠀⠀⣠⣿⠀⠀⠀⠉⠉⠀⠀⢀⣸⣿⠛⠉⠛⠛⠃⠀⠀⣸⣿⣿⣟⣛⠭⣶⣶⣖⡶⠶⡖⣲⡇⣤⠀⣤⣤⣤⣴⣿⣿⣿⠀⣤⠀⣤⣤⣤⣼⣿⣿⣁⡄⠀⡀⢀⡀⣄⣿⣿⣿⣿⣿⣿⣿⢩⣭⠽⡿⠿⠿⣿⡇⠸⠀⣿⣿⣿⣿⣿⣿⣿⠶⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⠀⠃⢸⣷⣿⣿⣿⣿⡿⣏⣿⣿⣿⣿⣧⣿⣷⣷⣿⣽⠍⠀⣯⣿⣿⣯⢿⠿⡿⣾⠍⠀⢽⣿⢿⠿⢽⣿⣿⠿⠿⠇⢸⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣿⣿⣿⣿⣾⡿⣿⣿⢿⠀⣿⣿⣿⣿⣿⣿⣿⢿⣿⡇⢸⣿⣾⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣯⣿⣷⣶⣶⣿⣿⣾⣾⣿⣿⣿⣿⣶⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿";PRINT(JPLYBBS);

//test colors

COLOR(10,0);
PRINT("RED ON BLACK");
COLOR(1,4);
PRINT("WHITE ON DARK GRAY");
COLOR(14,1);
PRINT("BLUE ON WHITE");

test Japanese

PRINT("日本語");

test 40 col

PRINT("012345678901234567890123456789012345678901")

todo list
//(fixed)bug seems it is not creating a newline when it reacher the end of hte width of the screen.
(done)add the COLOR(foregroudcolor,backroudcolor) command that takes numbers form getColor(colorNumber) by passing numbers as foreground and background colors, one it is called future print statements should use these foreground and background colors for the text being printed
add a bit of syntax sugar so it can be used more like BASIC 
*/
</script>
</body>
</html>
