<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C64 Full Screen Simulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
    :root {
        --c64-blue: #352879;
        --c64-lightblue: #706deb;
        --c64-cyan: #6cffee;
        --c64-border: #706deb;
    }

    html, body {
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        image-rendering: pixelated;
    }

    .cell {
        display: inline-block;
        width: 1ch;
        height: 1em;
        overflow: hidden;
    }


    .tv {
        width: 96vw;
        height: 96vh;
        max-width: 1400px;
        border: 20px solid var(--c64-border);
        border-radius: 30px;
        box-shadow:
            0 0 30px rgba(0,0,0,0.9),
            inset 0 0 40px rgba(0,0,0,0.6);
        background: var(--c64-blue);
        padding: 2vh 2vw;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
    }

    #screen {
        flex: 1;
        display: grid;
        grid-template-rows: repeat(25, 1fr);
        grid-template-columns: repeat(40, 1fr);
        background: var(--c64-blue);
        color: var(--c64-cyan);
        font-family: 'C64', monospace;
        font-size: clamp(12px, 2.2vh, 36px);
        line-height: 1;
        padding: 1vh 1vw;
        box-sizing: border-box;
    }

    .line {
        grid-column: 1 / -1;
        white-space: pre;
        overflow: hidden;
    }

    .double-wide {
        display: inline-block;
        transform: scaleX(2);
        transform-origin: left center;
    }

    .prompt { margin-right: 0.5ch; }

    #input-line {
        display: flex;
        align-items: center;
    }

    #command-input {
        background: transparent;
        border: none;
        outline: none;
        color: transparent;
        caret-color: transparent;
        font-family: 'C64', monospace;
        font-size: inherit;
        position: absolute;
        left: -9999px;
    }

    .cursor {
        display: inline-block;
        width: 1ch;
        background: var(--c64-cyan);
        animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink { to { visibility: hidden; } }

</style>
</head>

<body>
<div class="tv">
    <div id="screen"></div>
</div>

<script>
/* ==================================================
   GLOBALS
================================================== */
let echo = true;


let cursorX = 0;
let cursorY = 0;

let inputMode = null;
let currentFG = "#6cffee";     // default C64 cyan
let currentBG = "#352879";     // default C64 blue background


const screen = document.getElementById("screen");
const lines = [];

function ECHOOFF(){
    echo = false;
}
function ECHOON(){
    echo = true;
}

//have not tested this yet
function PLAY(url) {
  return new Promise((resolve) => {
    const audio = new Audio(url); // Create a new Audio element

    // Set up the 'ended' event listener to resolve the Promise
    audio.onended = () => {
      resolve();
    };

    // Handle potential errors, though not strictly required for basic play
    audio.onerror = (error) => {
      console.error("Audio playback error:", error);
      resolve(); // Resolve anyway so the rest of the script isn't stuck
    };

    audio.play().catch(error => {
        // Autoplay policies might catch this. User interaction is typically needed to start audio.
        console.error("Playback failed:", error);
        resolve();
    });
  });
}
function ASCIIART(str) {
    // normalize newlines
    str = str.replace(/\r/g, "");

    // strip leading/trailing blank lines
    str = str.replace(/^\s*\n+/, "").replace(/\n+\s*$/, "");

    // split into lines
    const lines = str.split("\n");

    // compute minimum indentation (in spaces/tabs) of non-empty lines
    let minIndent = Infinity;
    for (const ln of lines) {
    if (!ln.trim()) continue;
    const m = ln.match(/^[ \t]*/)[0].length;
    if (m < minIndent) minIndent = m;
    }
    if (!isFinite(minIndent)) minIndent = 0;

    // remove that indentation from every line, then join without separators
    return lines.map(l => l.slice(minIndent)).join("");
}
/* ==================================================
   BUILD 24 ROWS + INPUT LINE
================================================== */
function makeRow() {
    const d = document.createElement("div");
    d.className = "line";

    const wrap = document.createElement("span");
    wrap.className = "double-wide";

    for (let i = 0; i < 40; i++) {
        const cell = document.createElement("span");
        cell.className = "cell";
        cell.textContent = " ";
        wrap.appendChild(cell);
    }

    d.appendChild(wrap);
    return d;
}

for (let i = 0; i < 24; i++) {
    const row = makeRow();
    screen.appendChild(row);
    lines.push(row);
}

const inputLine = makeRow();
inputLine.id = "input-line";
inputLine.innerHTML =
    `<span class="double-wide prompt">></span>
     <span id="input-text"></span>
     <span class="cursor"> </span>`;
screen.appendChild(inputLine);
lines.push(inputLine);

const inputText = document.getElementById("input-text");

const commandInput = document.createElement("input");
commandInput.type = "text";
commandInput.id = "command-input";
document.body.appendChild(commandInput);

/* ==================================================
   UTILITY FUNCTIONS
================================================== */
function wide(text) {
    const span = document.createElement("span");
    span.className = "double-wide";
    span.textContent = text;
    return span;
}

function nextLine() {
    cursorX = 0;
    cursorY++;
    if (cursorY > 23) {
        const removed = lines.shift();
        if (removed !== inputLine) screen.removeChild(removed);
        const newRow = makeRow();
        screen.insertBefore(newRow, inputLine);
        lines.splice(23, 0, newRow);
        cursorY = 23;
    }
}

function LOCATE(x, y) {
    cursorX = Math.max(0, Math.min(39, parseInt(x)));
    cursorY = Math.max(0, Math.min(23, parseInt(y)));
}

function getColor(n) {
    const table = {
        0:"#000000", 1:"#ffffff", 2:"#808080", 3:"#b0c4de",
        4:"#a9a9a9", 7:"#c0c0c0", 8:"#dda0dd", 9:"#ee82ee",
        10:"#ff0000", 11:"#ffa500", 12:"#ffff00", 13:"#008000",
        14:"#0000ff", 15:"#4b0082", 16:"#ee82ee"
    };
    return table[n] || "#ffffff";
}

function COLOR(fg, bg) {
    if (fg !== undefined) currentFG = getColor(parseInt(fg));
    if (bg !== undefined) currentBG = getColor(parseInt(bg));
}

function echoCommand(cmd) {
    const row = lines[cursorY];
    row.innerHTML = "";
    const wrap = document.createElement("span");
    wrap.className = "double-wide";

    const promptSpan = document.createElement("span");
    promptSpan.textContent = ">";
    wrap.appendChild(promptSpan);

    const textSpan = document.createElement("span");
    textSpan.textContent = cmd;
    wrap.appendChild(textSpan);

    row.appendChild(wrap);
    nextLine();
}

function ensureRow(row) {
    if (row.firstChild && row.firstChild.classList.contains("double-wide")) {
        return row.firstChild;
    }

    const wrap = document.createElement("span");
    wrap.className = "double-wide";

    for (let i = 0; i < 40; i++) {
        const cell = document.createElement("span");
        cell.textContent = " ";
        wrap.appendChild(cell);
    }

    row.innerHTML = "";
    row.appendChild(wrap);
    return wrap;
}

function PUTCHAR(ch) {
    const row = lines[cursorY];
    const cell = row.firstChild.children[cursorX];

    cell.textContent = ch;
    cell.style.color = currentFG;
    cell.style.backgroundColor = currentBG;

    cursorX++;
    if (cursorX >= 40) nextLine();
}

/* ==================================================
   PRINT WITH WRAPPING + COLORS + ONE DOUBLE-WIDE WRAPPER
================================================== */

function parseAndPrint(text, slow = false, delay = 0) {
    let i = 0;
    const colorRegex = /^\[C\s*(\d+)\s*,\s*(\d+)\s*\]/;

    return (async () => {
        while (i < text.length) {
            if (text[i] === "[") {
                const match = text.slice(i).match(colorRegex);
                if (match) {
                    COLOR(parseInt(match[1]), parseInt(match[2]));
                    i += match[0].length;
                    continue;
                }
            }

            PUTCHAR(text[i]);
            i++;

            if (slow) await sleep(delay);
        }
    })();
}

function PRINT(text = "") {
    text = String(text);
    parseAndPrint(text);
    nextLine();
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function SLOWPRINT(text = "", time_ms = 50) {
    text = String(text);
    await parseAndPrint(text, true, time_ms);
}

function GOTO_INPUT_LINE() {
    cursorX = 0;
    cursorY = lines.length - 2;
}

/* ==================================================
   REAL INPUT()
================================================== */
commandInput.addEventListener("input", () => {
    inputText.textContent = commandInput.value;
});

function INPUT(promptText = "") {
    return new Promise(resolve => {

        if (promptText)
            PRINT(promptText);

        commandInput.value = "";
        inputText.textContent = "";

        inputMode = resolve;

        commandInput.focus();
    });
}

function preprocess(code) {
    return code.replace(
        /=\s*INPUT\s*\(/g,
        '= await INPUT('
    );
}

/* ==================================================
   MAIN KEYDOWN HANDLER
================================================== */
commandInput.addEventListener("keydown", async (e) => {

    if (e.key !== "Enter") return;

    const typed = commandInput.value.trim();

    if (inputMode) {
        if(echo) {
            echoCommand(typed);
        }
        const resolver = inputMode;
        inputMode = null;
        commandInput.value = "";
        inputText.textContent = "";
        resolver(typed);
        return;
    }

    if (typed === "") {
        commandInput.value = "";
        inputText.textContent = "";
        return;
    }
    if(echo) {
        echoCommand(typed);
    }

    commandInput.value = "";
    inputText.textContent = "";
    code=preprocess(typed);
    try {
        let result = await eval(`(async()=>{ ${code} })()`);
        if (result !== undefined) PRINT(result);
    } catch (err) {
        PRINT("?SYNTAX  ERROR:"+err);
    }

    GOTO_INPUT_LINE()
    PRINT("READY.");
    commandInput.focus();
});

/* ==================================================
   BOOT SCREEN
================================================== */
LOCATE(0,0);
PRINT("**** JPLY 64 JS_BASIC V1 ****");
PRINT("");
PRINT("64K RAM SYSTEM  38911 BASIC BYTES FREE");
PRINT("");
PRINT("READY.");
for (let i = 0; i < 17; i++) PRINT("");

document.addEventListener("click", () => commandInput.focus());
commandInput.focus();
/*
test input and locate 

ECHOOFF();
PRINT("ENTER NAME:");
A = await INPUT();
PRINT("HELLO " + A);
AGE = INPUT("AGE?");
PRINT("YOU ARE " + AGE + " YEARS OLD");
LOCATE(5,5);
PRINT("HELLO");
LOCATE(5,5);
PRINT("A");

oneliner
ECHOOFF(); PRINT("ENTER NAME:"); A =INPUT(); PRINT("HELLO " + A); AGE = INPUT("AGE?"); PRINT("YOU ARE " + AGE + " YEARS OLD"); LOCATE(5,5); PRINT("HELLO"); LOCATE(5,5); PRINT("A");


test UTF8ART art

ECHOOFF();
COLOR(0,10);LOCATE(0,0);
JPLYBBS =  '';
JPLYBBS += '⣟⣙⣿⡟⠛⠛⠛⠛⠻⠿⠟⠙⠚⠑⠏⢻⣙⣛⠊⠳⠛⠛⠛⢛⡑⠞⠿⠿⢛⡗⣋⣛⠿⠿⠻⠹⠚⡓⣋⣻';
JPLYBBS += '⡿⡿⣹⠧⢸⠉⠉⠉⣷⡏⠉⠉⠉⠉⠉⠿⠭⠩⢸⠉⠉⠉⢹⣮⠇⣿⠉⠩⠧⡵⠇⣯⢸⠉⠉⢹⣏⢷⡟⣿';
JPLYBBS += '⠧⠯⠥⠄⢸⠀⠀⠀⣿⡇⠀⠀⠀⣀⠀⠀⠀⠉⣾⠀⠀⠀⢸⣿⣷⣿⡀⠀⠀⠉⣶⣸⠉⠀⠀⢸⣿⣿⣭⠭';
JPLYBBS += '⣚⣿⢻⡏⢸⠀⠀⠀⣿⡇⠀⠀⠀⠿⠒⠀⠀⠀⣿⠀⠀⠀⢸⣿⣿⣿⣧⢠⠀⠀⠉⠉⠀⢠⠀⣿⣿⣿⣿⣿';
JPLYBBS += '⡊⣿⠛⠛⠚⠀⠀⠀⣿⡇⠀⠀⠀⣀⣀⣀⣤⣷⣿⠀⠀⠀⠘⠛⠛⠛⢻⣼⡶⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣧';
JPLYBBS += '⡅⣿⡀⠀⠀⠀⠀⣤⣿⡇⠀⠀⢀⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⠏⡋⢙⡇⠀⡇⣿⣿⣿⣧⣇⡇⢸⣿⣿⣿⡟⣿⢹⡀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡇⢸⢸⣿⣿⣿⠿⠿⠿⠟';
JPLYBBS += '⡛⣽⣿⣷⡂⣓⣿⣿⡏⠉⠉⠁⠈⠉⠙⠿⡍⣿⠉⠉⠉⠉⠉⠙⠛⢿⣿⣿⡿⠉⠀⠀⠈⠉⠙⢯⢩⡍⣥⣭';
JPLYBBS += '⢟⣙⢛⣛⣛⣛⣛⣛⡇⠀⠀⢠⣤⡄⠀⠀⠀⣿⠀⠀⠀⣤⣤⠀⠀⠀⢸⠀⠀⠀⣤⣶⣤⡀⣶⣿⣿⣖⣧⣿';
JPLYBBS += '⣭⣿⣿⣿⣷⣷⢿⣿⡇⠀⠀⠈⠉⠁⠀⣤⣿⣿⠀⠀⠀⠉⠉⠀⢠⣾⣿⠀⠀⠀⠈⠉⠉⠿⢿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⢿⣿⣿⣏⣿⣿⢿⡇⠀⠀⢰⣶⡆⠀⠀⠉⣿⠀⠀⠀⣶⣶⠀⠀⠀⢹⣶⡇⣄⣀⣀⡀⠀⠀⢸⣿⣻⣿⣿';
JPLYBBS += '⣼⣶⣚⣻⣿⣷⣯⣶⡇⠀⠀⠈⠉⠁⠀⠀⣠⣿⠀⠀⠀⠉⠉⠀⠀⢀⣸⣿⠛⠉⠛⠛⠃⠀⠀⣸⣿⣿⣟⣛';
JPLYBBS += '⠭⣶⣶⣖⡶⠶⡖⣲⡇⣤⠀⣤⣤⣤⣴⣿⣿⣿⠀⣤⠀⣤⣤⣤⣼⣿⣿⣁⡄⠀⡀⢀⡀⣄⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⢩⣭⠽⡿⠿⠿⣿⡇⠸⠀⣿⣿⣿⣿⣿⣿⣿⠶⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⠀⠃⢸⣷⣿⣿⣿⣿⡿⣏⣿';
JPLYBBS += '⣿⣿⣿⣧⣿⣷⣷⣿⣽⠍⠀⣯⣿⣿⣯⢿⠿⡿⣾⠍⠀⢽⣿⢿⠿⢽⣿⣿⠿⠿⠇⢸⣿⣿⣿⣿⣿⣿⡿⣿';
JPLYBBS += '⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣿⣿⣿⣿⣾⡿⣿⣿⢿⠀⣿⣿⣿⣿⣿⣿⣿⢿⣿⡇⢸⣿⣾⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣯⣿⣷⣶⣶⣿⣿⣾⣾⣿⣿⣿⣿⣶⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿';
PRINT(JPLYBBS);


onelienr
ECHOOFF();COLOR(0,10);LOCATE(0,0);JPLYBBS =  '';JPLYBBS += '⣟⣙⣿⡟⠛⠛⠛⠛⠻⠿⠟⠙⠚⠑⠏⢻⣙⣛⠊⠳⠛⠛⠛⢛⡑⠞⠿⠿⢛⡗⣋⣛⠿⠿⠻⠹⠚⡓⣋⣻';JPLYBBS += '⡿⡿⣹⠧⢸⠉⠉⠉⣷⡏⠉⠉⠉⠉⠉⠿⠭⠩⢸⠉⠉⠉⢹⣮⠇⣿⠉⠩⠧⡵⠇⣯⢸⠉⠉⢹⣏⢷⡟⣿';JPLYBBS += '⠧⠯⠥⠄⢸⠀⠀⠀⣿⡇⠀⠀⠀⣀⠀⠀⠀⠉⣾⠀⠀⠀⢸⣿⣷⣿⡀⠀⠀⠉⣶⣸⠉⠀⠀⢸⣿⣿⣭⠭';JPLYBBS += '⣚⣿⢻⡏⢸⠀⠀⠀⣿⡇⠀⠀⠀⠿⠒⠀⠀⠀⣿⠀⠀⠀⢸⣿⣿⣿⣧⢠⠀⠀⠉⠉⠀⢠⠀⣿⣿⣿⣿⣿';JPLYBBS += '⡊⣿⠛⠛⠚⠀⠀⠀⣿⡇⠀⠀⠀⣀⣀⣀⣤⣷⣿⠀⠀⠀⠘⠛⠛⠛⢻⣼⡶⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣧';JPLYBBS += '⡅⣿⡀⠀⠀⠀⠀⣤⣿⡇⠀⠀⢀⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣿';JPLYBBS += '⠏⡋⢙⡇⠀⡇⣿⣿⣿⣧⣇⡇⢸⣿⣿⣿⡟⣿⢹⡀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡇⢸⢸⣿⣿⣿⠿⠿⠿⠟';JPLYBBS += '⡛⣽⣿⣷⡂⣓⣿⣿⡏⠉⠉⠁⠈⠉⠙⠿⡍⣿⠉⠉⠉⠉⠉⠙⠛⢿⣿⣿⡿⠉⠀⠀⠈⠉⠙⢯⢩⡍⣥⣭';JPLYBBS += '⢟⣙⢛⣛⣛⣛⣛⣛⡇⠀⠀⢠⣤⡄⠀⠀⠀⣿⠀⠀⠀⣤⣤⠀⠀⠀⢸⠀⠀⠀⣤⣶⣤⡀⣶⣿⣿⣖⣧⣿';JPLYBBS += '⣭⣿⣿⣿⣷⣷⢿⣿⡇⠀⠀⠈⠉⠁⠀⣤⣿⣿⠀⠀⠀⠉⠉⠀⢠⣾⣿⠀⠀⠀⠈⠉⠉⠿⢿⣿⣿⣿⣿⣿';JPLYBBS += '⣿⢿⣿⣿⣏⣿⣿⢿⡇⠀⠀⢰⣶⡆⠀⠀⠉⣿⠀⠀⠀⣶⣶⠀⠀⠀⢹⣶⡇⣄⣀⣀⡀⠀⠀⢸⣿⣻⣿⣿';JPLYBBS += '⣼⣶⣚⣻⣿⣷⣯⣶⡇⠀⠀⠈⠉⠁⠀⠀⣠⣿⠀⠀⠀⠉⠉⠀⠀⢀⣸⣿⠛⠉⠛⠛⠃⠀⠀⣸⣿⣿⣟⣛';JPLYBBS += '⠭⣶⣶⣖⡶⠶⡖⣲⡇⣤⠀⣤⣤⣤⣴⣿⣿⣿⠀⣤⠀⣤⣤⣤⣼⣿⣿⣁⡄⠀⡀⢀⡀⣄⣿⣿⣿⣿⣿⣿';JPLYBBS += '⣿⢩⣭⠽⡿⠿⠿⣿⡇⠸⠀⣿⣿⣿⣿⣿⣿⣿⠶⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⠀⠃⢸⣷⣿⣿⣿⣿⡿⣏⣿';JPLYBBS += '⣿⣿⣿⣧⣿⣷⣷⣿⣽⠍⠀⣯⣿⣿⣯⢿⠿⡿⣾⠍⠀⢽⣿⢿⠿⢽⣿⣿⠿⠿⠇⢸⣿⣿⣿⣿⣿⣿⡿⣿';JPLYBBS += '⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣿⣿⣿⣿⣾⡿⣿⣿⢿⠀⣿⣿⣿⣿⣿⣿⣿⢿⣿⡇⢸⣿⣾⣿⣿⣿⣿⣿⣿';JPLYBBS += '⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣯⣿⣷⣶⣶⣿⣿⣾⣾⣿⣿⣿⣿⣶⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿';PRINT(JPLYBBS);

//test colors

COLOR(10,0);
PRINT("RED ON BLACK");
COLOR(1,4);
PRINT("WHITE ON DARK GRAY");
COLOR(14,1);
PRINT("BLUE ON WHITE");

oneliner
COLOR(10,0);PRINT("RED ON BLACK");COLOR(1,4);PRINT("WHITE ON DARK GRAY");COLOR(14,1);PRINT("BLUE ON WHITE");

test Japanese

PRINT("日本語");

test 40 col

PRINT("012345678901234567890123456789012345678901")


test PLAY

PRINT("now playing");
PLAY("audio/modem.mp3");
PRINT("Ended playing");

test slowprint progra

ECHOOFF();
JPLYBBS =  '';
JPLYBBS += '⣟⣙⣿⡟⠛⠛⠛⠛⠻⠿⠟⠙⠚⠑⠏⢻⣙⣛⠊⠳⠛⠛⠛⢛⡑⠞⠿⠿⢛⡗⣋⣛⠿⠿⠻⠹⠚⡓⣋⣻';
JPLYBBS += '⡿⡿⣹⠧⢸⠉⠉⠉⣷⡏⠉⠉⠉⠉⠉⠿⠭⠩⢸⠉⠉⠉⢹⣮⠇⣿⠉⠩⠧⡵⠇⣯⢸⠉⠉⢹⣏⢷⡟⣿';
JPLYBBS += '⠧⠯⠥⠄⢸⠀⠀⠀⣿⡇⠀⠀⠀⣀⠀⠀⠀⠉⣾⠀⠀⠀⢸⣿⣷⣿⡀⠀⠀⠉⣶⣸⠉⠀⠀⢸⣿⣿⣭⠭';
JPLYBBS += '⣚⣿⢻⡏⢸⠀⠀⠀⣿⡇⠀⠀⠀⠿⠒⠀⠀⠀⣿⠀⠀⠀⢸⣿⣿⣿⣧⢠⠀⠀⠉⠉⠀⢠⠀⣿⣿⣿⣿⣿';
JPLYBBS += '⡊⣿⠛⠛⠚⠀⠀⠀⣿⡇⠀⠀⠀⣀⣀⣀⣤⣷⣿⠀⠀⠀⠘⠛⠛⠛⢻⣼⡶⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣧';
JPLYBBS += '⡅⣿⡀⠀⠀⠀⠀⣤⣿⡇⠀⠀⢀⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⠏⡋⢙⡇⠀⡇⣿⣿⣿⣧⣇⡇⢸⣿⣿⣿⡟⣿⢹⡀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡇⢸⢸⣿⣿⣿⠿⠿⠿⠟';
JPLYBBS += '⡛⣽⣿⣷⡂⣓⣿⣿⡏⠉⠉⠁⠈⠉⠙⠿⡍⣿⠉⠉⠉⠉⠉⠙⠛⢿⣿⣿⡿⠉⠀⠀⠈⠉⠙⢯⢩⡍⣥⣭';
JPLYBBS += '⢟⣙⢛⣛⣛⣛⣛⣛⡇⠀⠀⢠⣤⡄⠀⠀⠀⣿⠀⠀⠀⣤⣤⠀⠀⠀⢸⠀⠀⠀⣤⣶⣤⡀⣶⣿⣿⣖⣧⣿';
JPLYBBS += '⣭⣿⣿⣿⣷⣷⢿⣿⡇⠀⠀⠈⠉⠁⠀⣤⣿⣿⠀⠀⠀⠉⠉⠀⢠⣾⣿⠀⠀⠀⠈⠉⠉⠿⢿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⢿⣿⣿⣏⣿⣿⢿⡇⠀⠀⢰⣶⡆⠀⠀⠉⣿⠀⠀⠀⣶⣶⠀⠀⠀⢹⣶⡇⣄⣀⣀⡀⠀⠀⢸⣿⣻⣿⣿';
JPLYBBS += '⣼⣶⣚⣻⣿⣷⣯⣶⡇⠀⠀⠈⠉⠁⠀⠀⣠⣿⠀⠀⠀⠉⠉⠀⠀⢀⣸⣿⠛⠉⠛⠛⠃⠀⠀⣸⣿⣿⣟⣛';
JPLYBBS += '⠭⣶⣶⣖⡶⠶⡖⣲⡇⣤⠀⣤⣤⣤⣴⣿⣿⣿⠀⣤⠀⣤⣤⣤⣼⣿⣿⣁⡄⠀⡀⢀⡀⣄⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⢩⣭⠽⡿⠿⠿⣿⡇⠸⠀⣿⣿⣿⣿⣿⣿⣿⠶⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⠀⠃⢸⣷⣿⣿⣿⣿⡿⣏⣿';
JPLYBBS += '⣿⣿⣿⣧⣿⣷⣷⣿⣽⠍⠀⣯⣿⣿⣯⢿⠿⡿⣾⠍⠀⢽⣿⢿⠿⢽⣿⣿⠿⠿⠇⢸⣿⣿⣿⣿⣿⣿⡿⣿';
JPLYBBS += '⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣿⣿⣿⣿⣾⡿⣿⣿⢿⠀⣿⣿⣿⣿⣿⣿⣿⢿⣿⡇⢸⣿⣾⣿⣿⣿⣿⣿⣿';
JPLYBBS += '⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣯⣿⣷⣶⣶⣿⣿⣾⣾⣿⣿⣿⣿⣶⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿';

COLOR(0,10);LOCATE(0,0);
await SLOWPRINT("2400    bps     4.17ms  1984",4.17);
PRINT("");
await SLOWPRINT(JPLYBBS,4.17);

COLOR(0,9);LOCATE(0,0);
await SLOWPRINT("14.4    kbps    2ms     1991",2);
PRINT("");
await SLOWPRINT(JPLYBBS,2);

COLOR(0,8);LOCATE(0,0);
await SLOWPRINT("56      kbps    0.69ms  1998",0.69);
PRINT("");
await SLOWPRINT(JPLYBBS,0.69);

COLOR(0,7);LOCATE(0,0);
await SLOWPRINT("110     bps     90.9ms  1950",90.9);
PRINT("");
await SLOWPRINT(JPLYBBS,90.9);


modem speeds
110     bps     90.9ms  1950
2400    bps     4.17ms  1984
14.4    kbps    2ms     1991
56      kbps    0.69ms  1998

ECHOOFF();
COLOR(0,10);LOCATE(0,0);
JPLYBBS =  '';
JPLYBBS += '⣟⣙⣿⡟⠛⠛⠛⠛⠻⠿⠟⠙⠚⠑⠏⢻⣙⣛⠊⠳⠛⠛⠛⢛⡑⠞⠿⠿⢛⡗⣋⣛⠿⠿⠻⠹⠚⡓⣋⣻';
JPLYBBS += '⣟⣙⣿⡟⠛';
SLOWPRINT(JPLYBBS,30);

todo list
//(fixed)bug seems it is not creating a newline when it reacher the end of hte width of the screen.
(done)add the COLOR(foregroudcolor,backroudcolor) command that takes numbers form getColor(colorNumber) by passing numbers as foreground and background colors, one it is called future print statements should use these foreground and background colors for the text being printed
add a bit of syntax sugar so it can be used more like BASIC 

add:
TYPE HELP() FOR HELP THEN PRESS [ENTER]
TYPE HELPJP()を打ってそして[ENTER]を押して、日本語のヘルプを表示します
ESCRIBA HELPES() Y PRESIONE [ENTER} PARA AYUDA EN ESPAÑOL

TYPE ATDT+15593278 TO CONNECT TO ENGLISH JPLY BBS
ATDT+815593278を打ったら。JPLY BSSの日本版に入ります
ESCRIBA ATDT+525593278 PARA CONNECTARSE A JPLY BBS EN ESPAÑOL


HELP IN ENGLISH
ECHOOFF();
TURNS COMMAND ECHO OFF
ECHON();
TURNS COMMAND ECHO ON
PRINT("HELLO WORLD!:");
PRINTS HELLO WORLD!
VARNAME = INPUT()
AWAITS FOR USER TO INPUT AND PRESS ENTER, THEN STORES VALUE IN VARIABLE VARNAME
COLOR(0-15,0-15);
CHANGES THE COLOR OF THE FOREGROUND AND BACKGROUD
LOCATE(X, X)
CHANGES THE POSITION OF THE NEXT PRINT STATEMENT TO X AND Y COORDINATES
PLAY(URL);
PLAYS THE SOUND LOCATED AT STRING IN URL VARIABLE
HELP()
DISPLAYS THIS HELP SCREEN

TYPE ATDT+15593278 TO CONNECT TO ENGLISH JPLY BBS
ATDT+815593278を打ったら。JPLY BSSの日本版に入ります
ESCRIBA ATDT+525593278 PARA CONNECTARSE A JPLY BBS EN ESPAÑOL


amigojapan> Emmanuel_Chanel: こんにちは
3:19 PM <amigojapan> Emmanuel_Chanel: BBSって知ってますか？
3:19 PM <Emmanuel_Chanel> ウェブ上の掲示板を日本ではそう呼びますね。
3:20 PM <Emmanuel_Chanel> Bullet-in Board System だかの略で。
3:21 PM <amigojapan> Emmanuel_Chanel: アメリカには1978年からありました、インターネット上じゃなくて、８ビットパソコンで使った
3:21 PM <amigojapan> はい
3:21 PM <Emmanuel_Chanel> 確かに、ウェブ上の掲示板とは別にそんなシステムがあるというのは、私も大学で習いました。
3:21 PM <amigojapan> 今古いBBSシミュレーターを作ってます
3:22 PM <amigojapan> へー
3:23 PM <amigojapan> Emmanuel_Chanel: WEBは1989年で始まりました
    amigojapan> １１年間WEBの前のBBSありました


JPLY BBS rules:
do not post inappropriate material, sware-words or attack other users.

where to get all the ascii charaters for making boarders liike in Vistual BBS
https://www.ascii.ca/cp437.htm

add some upper art?
Main Menu

--Page Sysop
--Door Games(BASIC interpreter, American football, darts)
--Warez(what to put here? maybe link t JPLY games? self ad or actual ---way to download JPLY games)
--Bulletin Board(threads, posts)
--Mail
--who(list all users)
--Finger(list onlie users)
--Chat(as if it were a multi-line BBS)?
--Abour JPLY BBS
--Quit
Comment



submenues

Mail
---list
---read
---write

Bout
---revival of Mexico city BBS called Night NAK form late 80s
by same SysOp, same phone number displayed. English, Japanese
and Spanish supported.
now published as JPLY becuase that is the company I am
wokring at.
The idea is to give a taste of what BBS were like in the past
to the people who never had a chance to try the,
and also inspire the nostalgia in those who lived through
that era.

SeeRaaMuulator - is a word I just coined, which , means a software that just simulates the look and feel of something, not the actual function of the thing being simulated. SailorMulator maybe  better in English I guess? synonym: skeumorphism
*/
</script>
</body>
</html>
