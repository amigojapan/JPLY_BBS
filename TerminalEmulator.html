<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C64 Full Screen Simulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
    :root {
        --c64-blue: #352879;
        --c64-lightblue: #706deb;
        --c64-cyan: #6cffee;
        --c64-border: #706deb;
    }

    html, body {
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        image-rendering: pixelated;
    }

    .tv {
        width: 96vw;
        height: 96vh;
        max-width: 1400px;
        border: 20px solid var(--c64-border);
        border-radius: 30px;
        box-shadow:
            0 0 30px rgba(0,0,0,0.9),
            inset 0 0 40px rgba(0,0,0,0.6);
        background: var(--c64-blue);
        padding: 2vh 2vw;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
    }

    #screen {
        flex: 1;
        display: grid;
        grid-template-rows: repeat(25, 1fr);
        grid-template-columns: repeat(40, 1fr);
        background: var(--c64-blue);
        color: var(--c64-cyan);
        font-family: 'C64', monospace;
        font-size: clamp(12px, 2.2vh, 36px);
        line-height: 1;
        padding: 1vh 1vw;
        box-sizing: border-box;
    }

    .line {
        grid-column: 1 / -1;
        white-space: pre;
        overflow: hidden;
    }

    .double-wide {
        display: inline-block;
        transform: scaleX(2);
        transform-origin: left center;
    }

    .prompt { margin-right: 0.5ch; }

    #input-line {
        display: flex;
        align-items: center;
        color: var(--c64-cyan);
    }

    #command-input {
        background: transparent;
        border: none;
        outline: none;
        color: var(--c64-cyan);
        font-family: 'C64', monospace;
        font-size: inherit;
        flex: 1;
        caret-color: transparent;
    }

    .cursor {
        display: inline-block;
        width: 1ch;
        background: var(--c64-cyan);
        animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink { to { visibility: hidden; } }

    @font-face {
        font-family: 'C64';
        src: url(data:font/ttf;base64,AAEAAAALAIAAAwAwT1MvMg8SPh0AAAC8AAAAYGNtYXAYVB9VAAABHAAAAFRnYXNwAAAAEAAAA+gAAAAIZ2x5ZlQ1T7AAABAkAAAEKGhlYWQHpD4bAAAANAAAADZoaGVhBnQC8AAAAzgAAAAkaG10eC7q9gAAAEAAAAAUbG9jYQA4AFAAAABsAAAAGm1heHAApgm8AAAA5AAAAAdubWRhBsT+3gAAAOwAAAABAAAAAgAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAQAABdoAAAABAAAAAAAQAAAQAAAAAAAgAABAAAAAAA6AAAAAgABAAAAAAACAAcAAQAAAAAAAwAA ...) format('truetype');
    }
</style>
</head>

<body>
<div class="tv">
    <div id="screen"></div>
</div>

<script>
/* -------------------------------------------------
   GLOBAL CURSOR & SCREEN SETUP
-------------------------------------------------- */
let cursorX = 0;
let cursorY = 0;

// INPUT mode flag: null = command mode, otherwise = resolver function
let inputMode = null;

let echo = true;

const screen = document.getElementById('screen');
const lines = [];

function ECHOOFF(){
    echo = false;
}
function ECHOON(){
    echo = true;
}

function makeRow() {
    const d = document.createElement('div');
    d.className = 'line';
    return d;
}

// 24 printable rows
for (let i = 0; i < 24; i++) {
    const row = makeRow();
    screen.appendChild(row);
    lines.push(row);
}

// Input line
const inputLine = makeRow();
inputLine.id = 'input-line';
inputLine.innerHTML =
    `<span class="double-wide prompt">></span>
     <span id="input-text"></span>
     <span class="cursor"> </span>`;
screen.appendChild(inputLine);
lines.push(inputLine);

const inputText = document.getElementById('input-text');

// hidden input handler
const commandInput = document.createElement('input');
commandInput.type = 'text';
commandInput.id = 'command-input';
document.body.appendChild(commandInput);

function wide(text) {
    const span = document.createElement('span');
    span.className = 'double-wide';
    span.textContent = text;
    return span;
}

function nextLine() {
    cursorX = 0;
    cursorY++;
    if (cursorY > 23) {
        const removed = lines.shift();
        if (removed !== inputLine) screen.removeChild(removed);
        const newRow = makeRow();
        screen.insertBefore(newRow, inputLine);
        lines.splice(23, 0, newRow);
        cursorY = 23;
    }
}

function LOCATE(x, y) {
    cursorX = Math.max(0, Math.min(39, parseInt(x)));
    cursorY = Math.max(0, Math.min(23, parseInt(y)));
}

function PRINT(text = "") {
    text = String(text);

    let idx = 0;

    while (idx < text.length) {

        const row = lines[cursorY];

        // Get current row text padded to 40 chars
        let current = row.textContent || "";
        current = current.padEnd(40, " ");
        let arr = current.split("");

        // How many characters fit?
        let space = 40 - cursorX;
        let chunk = text.substring(idx, idx + space);

        // Write chunk
        for (let i = 0; i < chunk.length; i++) {
            arr[cursorX + i] = chunk[i];
        }

        // Update row
        row.innerHTML = "";
        row.appendChild(wide(arr.join("")));

        // Advance indices
        cursorX += chunk.length;
        idx += chunk.length;

        // If row is full, wrap
        if (cursorX >= 40) {
            nextLine();
        }
    }

    // After printing entire text, always go to next line
    nextLine();
}

function echoCommand(cmd) {
    const row = lines[cursorY];
    row.innerHTML = "";
    const p = document.createElement('span');
    p.className = 'double-wide prompt';
    p.textContent = ">";
    row.appendChild(p);
    row.appendChild(wide(cmd));
    nextLine();
}

commandInput.addEventListener('input', ()=>{
    inputText.textContent = commandInput.value;
});

/* -------------------------------------------------
   REAL WORKING INPUT() USING REAL INPUT LINE
-------------------------------------------------- */
function INPUT(promptText = "") {
    return new Promise(resolve => {

        if (promptText)
            PRINT(promptText);

        commandInput.value = "";
        inputText.textContent = "";

        // Enter INPUT mode (handled inside keydown)
        inputMode = resolve;

        commandInput.focus();
    });
}

/* -------------------------------------------------
   THE ONE TRUE KEYDOWN HANDLER (handles INPUT + commands)
-------------------------------------------------- */
commandInput.addEventListener('keydown', async (e) => {

    if (e.key !== 'Enter') return;

    const typed = commandInput.value.trim();

    /* ------------------------------
       INPUT MODE: RETURN TO USER
    --------------------------------*/
    if (inputMode) {
        if(echo) {
            echoCommand(typed);
        }
        const resolver = inputMode;
        inputMode = null;

        commandInput.value = "";
        inputText.textContent = "";

        resolver(typed);
        return;
    }

    /* ---------------------------------
       NORMAL COMMAND MODE
    ---------------------------------- */
    if (typed === '') {
        commandInput.value = '';
        inputText.textContent = '';
        return;
    }
    if(echo) {
        echoCommand(typed);
    }
    commandInput.value = '';
    inputText.textContent = '';
    
    const originalCode = typed;
    //replace INPUT with await INPUT
    // Use a regular expression with the global flag (/g) to replace all occurrences.
    //const updatedCode = originalCode.replace(/= INPUT\(/g, '= await INPUT(');
    //modify this code so that it replaces anys paces between = and INPUT with await no matter how many spaces tere are: const updatedCode = originalCode.replace(/= INPUT\(/g, '= await INPUT(');
    const updatedCode = originalCode.replace(/=\s*INPUT\(/g, '= await INPUT(');
    //alert(updatedCode);


    try {
        let result = await eval(`(async()=>{ ${updatedCode} })()`);
        if (result !== undefined) PRINT(result);
    } catch (err) {
        PRINT("?SYNTAX  ERROR:"+err);
    }

    PRINT("READY.");
    commandInput.focus();
});

/* -------------------------------------------------
   BOOT TEXT
-------------------------------------------------- */
LOCATE(0,0);
PRINT("**** JPLY 64 JS_BASIC V1 ****");
PRINT("");
PRINT("64K RAM SYSTEM  38911 BASIC BYTES FREE");
PRINT("");
PRINT("READY.");
for (let i=0;i<17;i++) PRINT("");

document.addEventListener('click', ()=> commandInput.focus());
commandInput.focus();
/*
//test input and locate 

ECHOOFF();
PRINT("ENTER NAME:");
A =INPUT();
PRINT("HELLO " + A);
AGE = INPUT("AGE?");
PRINT("YOU ARE " + AGE + " YEARS OLD");
LOCATE(5,5);
PRINT("HELLO");
LOCATE(5,5);
PRINT("A");

PRINT("ENTER NAME:");A =INPUT();PRINT("HELLO " + A);AGE = INPUT("AGE?");PRINT("YOU ARE " + AGE + " YEARS OLD");LOCATE(5,5);PRINT("HELLO");LOCATE(5,5);PRINT("A");

this is the news on my C64 simulator , I added the INPUT command, fixed soime bugs too, including the one of LOCATE that you mentiones, please try it amjp.psy-k.org/JPLY_BBS/TerminalEmulator.html this is the sample program to test everything PRINT("ENTER NAME:");A =INPUT();PRINT("HELLO " + A);AGE = INPUT("AGE?");PRINT("YOU ARE " + AGE + " YEARS OLD");LOCATE(5,5);PRINT("HELLO");LOCATE(5,5);PRINT("A");
tomorrow I think I will add the COLOR command, and maybe a b it of syntax sugar so it can be used more like BASIC 
// Define a variable using backticks (`)
LOCATE(0,0);JPLYBBS = "⣟⣙⣿⡟⠛⠛⠛⠛⠻⠿⠟⠙⠚⠑⠏⢻⣙⣛⠊⠳⠛⠛⠛⢛⡑⠞⠿⠿⢛⡗⣋⣛⠿⠿⠻⠹⠚⡓⣋⣻⡿⡿⣹⠧⢸⠉⠉⠉⣷⡏⠉⠉⠉⠉⠉⠿⠭⠩⢸⠉⠉⠉⢹⣮⠇⣿⠉⠩⠧⡵⠇⣯⢸⠉⠉⢹⣏⢷⡟⣿⠧⠯⠥⠄⢸⠀⠀⠀⣿⡇⠀⠀⠀⣀⠀⠀⠀⠉⣾⠀⠀⠀⢸⣿⣷⣿⡀⠀⠀⠉⣶⣸⠉⠀⠀⢸⣿⣿⣭⠭⣚⣿⢻⡏⢸⠀⠀⠀⣿⡇⠀⠀⠀⠿⠒⠀⠀⠀⣿⠀⠀⠀⢸⣿⣿⣿⣧⢠⠀⠀⠉⠉⠀⢠⠀⣿⣿⣿⣿⣿⡊⣿⠛⠛⠚⠀⠀⠀⣿⡇⠀⠀⠀⣀⣀⣀⣤⣷⣿⠀⠀⠀⠘⠛⠛⠛⢻⣼⡶⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣧⡅⣿⡀⠀⠀⠀⠀⣤⣿⡇⠀⠀⢀⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀⠀⢸⢸⣿⣿⣿⣿⣿⣿⠏⡋⢙⡇⠀⡇⣿⣿⣿⣧⣇⡇⢸⣿⣿⣿⡟⣿⢹⡀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡇⢸⢸⣿⣿⣿⠿⠿⠿⠟⡛⣽⣿⣷⡂⣓⣿⣿⡏⠉⠉⠁⠈⠉⠙⠿⡍⣿⠉⠉⠉⠉⠉⠙⠛⢿⣿⣿⡿⠉⠀⠀⠈⠉⠙⢯⢩⡍⣥⣭⢟⣙⢛⣛⣛⣛⣛⣛⡇⠀⠀⢠⣤⡄⠀⠀⠀⣿⠀⠀⠀⣤⣤⠀⠀⠀⢸⠀⠀⠀⣤⣶⣤⡀⣶⣿⣿⣖⣧⣿⣭⣿⣿⣿⣷⣷⢿⣿⡇⠀⠀⠈⠉⠁⠀⣤⣿⣿⠀⠀⠀⠉⠉⠀⢠⣾⣿⠀⠀⠀⠈⠉⠉⠿⢿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣏⣿⣿⢿⡇⠀⠀⢰⣶⡆⠀⠀⠉⣿⠀⠀⠀⣶⣶⠀⠀⠀⢹⣶⡇⣄⣀⣀⡀⠀⠀⢸⣿⣻⣿⣿⣼⣶⣚⣻⣿⣷⣯⣶⡇⠀⠀⠈⠉⠁⠀⠀⣠⣿⠀⠀⠀⠉⠉⠀⠀⢀⣸⣿⠛⠉⠛⠛⠃⠀⠀⣸⣿⣿⣟⣛⠭⣶⣶⣖⡶⠶⡖⣲⡇⣤⠀⣤⣤⣤⣴⣿⣿⣿⠀⣤⠀⣤⣤⣤⣼⣿⣿⣁⡄⠀⡀⢀⡀⣄⣿⣿⣿⣿⣿⣿⣿⢩⣭⠽⡿⠿⠿⣿⡇⠸⠀⣿⣿⣿⣿⣿⣿⣿⠶⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⠀⠃⢸⣷⣿⣿⣿⣿⡿⣏⣿⣿⣿⣿⣧⣿⣷⣷⣿⣽⠍⠀⣯⣿⣿⣯⢿⠿⡿⣾⠍⠀⢽⣿⢿⠿⢽⣿⣿⠿⠿⠇⢸⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣿⣿⣿⣿⣾⡿⣿⣿⢿⠀⣿⣿⣿⣿⣿⣿⣿⢿⣿⡇⢸⣿⣾⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣯⣿⣷⣶⣶⣿⣿⣾⣾⣿⣿⣿⣿⣶⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿";PRINT(JPLYBBS);


PRINT("日本語");
PRINT("012345678901234567890123456789012345678901")
//nug seems it is not creating a newline when it reacher the end of hte width of the screen.
*/
</script>
</body>
</html>
