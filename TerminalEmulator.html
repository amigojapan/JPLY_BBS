<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C64 SailorMuulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
    :root {
        --c64-blue: #352879;
        --c64-lightblue: #706deb;
        --c64-cyan: #6cffee;
        --c64-border: #706deb;
    }

    html, body {
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        image-rendering: pixelated;
    }

    .cell {
        display: inline-block;
        min-height: 1em;
    }


    .tv {
        width: 96vw;
        height: 96vh;
        max-width: 1400px;
        border: 20px solid var(--c64-border);
        border-radius: 30px;
        box-shadow:
            0 0 30px rgba(0,0,0,0.9),
            inset 0 0 40px rgba(0,0,0,0.6);
        background: var(--c64-blue);
        padding: 2vh 2vw;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
    }

    #screen {
        flex: 1;
        display: grid;
        grid-template-rows: repeat(25, 1fr);
        grid-template-columns: repeat(40, 1fr);
        background: var(--c64-blue);
        color: var(--c64-cyan);
        font-family: 'C64', 'Noto Sans JP', 'MS Gothic', monospace;
        font-size: var(--dynamic-font-size, clamp(12px, 1.5vh, 36px));
        /*change middle value to change font size*/
        line-height: 1;
        padding: 1vh 1vw;
        box-sizing: border-box;
    }

    .line {
        grid-column: 1 / -1;
        white-space: pre;
        overflow: hidden;
    }

    /*.double-wide {
        display: inline-block;
        transform: scaleX(2);
        transform-origin: left center;
    }*/

    .prompt { margin-right: 0.5ch; }

    #input-line {
        display: flex;
        align-items: center;
    }

    #command-input {
        background: transparent;
        border: none;
        outline: none;
        color: transparent;
        caret-color: transparent;
        font-family: 'C64', monospace;
        font-size: inherit;
        /*
        position: absolute;
        left: -9999px;
        */
        position: fixed;
        top: 0;
        left: 0;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
        z-index: -1;
    }

    .cursor {
        display: inline-block;
        width: 1ch;
        background: var(--c64-cyan);
        animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink { to { visibility: hidden; } }

</style>
</head>

<body>
<script src="i18n.js"></script>
<div class="tv">
    <div id="screen"></div>
</div>

<script>
/* ==================================================
   GLOBALS
================================================== */
let echo = true;


let cursorX = 0;
let cursorY = 0;

let inputMode = null;
let currentFG = "#6cffee";     // default C64 cyan
let currentBG = "#352879";     // default C64 blue background


const screen = document.getElementById("screen");
const lines = [];

function isMobileDevice() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    // Check for common mobile keywords
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
        return true;
    }
    return false;
}

if (isMobileDevice()) {
    console.log("Running on a mobile device.");
} else {
    console.log("Running on a desktop or non-mobile device.");
}

// Check if user agent contains mobile-specific keywords
const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

// Select the element (e.g., the root or a specific class)
const root = document.documentElement;

if (!isMobile) {
    document.documentElement.style
        .setProperty('--dynamic-font-size', 'calc(clamp(12px, 1.5vh, 36px) * 2)');
}
function ECHOOFF(){
    echo = false;
}
function ECHOON(){
    echo = true;
}

//have not tested this yet
function PLAY(url) {
  return new Promise((resolve) => {
    const audio = new Audio(url); // Create a new Audio element

    // Set up the 'ended' event listener to resolve the Promise
    audio.onended = () => {
      resolve();
    };

    // Handle potential errors, though not strictly required for basic play
    audio.onerror = (error) => {
      console.error("Audio playback error:", error);
      resolve(); // Resolve anyway so the rest of the script isn't stuck
    };

    audio.play().catch(error => {
        // Autoplay policies might catch this. User interaction is typically needed to start audio.
        console.error("Playback failed:", error);
        resolve();
    });
  });
}
function ASCIIART(str) {
    // normalize newlines
    str = str.replace(/\r/g, "");

    // strip leading/trailing blank lines
    str = str.replace(/^\s*\n+/, "").replace(/\n+\s*$/, "");

    // split into lines
    const lines = str.split("\n");

    // compute minimum indentation (in spaces/tabs) of non-empty lines
    let minIndent = Infinity;
    for (const ln of lines) {
    if (!ln.trim()) continue;
    const m = ln.match(/^[ \t]*/)[0].length;
    if (m < minIndent) minIndent = m;
    }
    if (!isFinite(minIndent)) minIndent = 0;

    // remove that indentation from every line, then join without separators
    return lines.map(l => l.slice(minIndent)).join("");
}
/* ==================================================
   BUILD 24 ROWS + INPUT LINE
================================================== */
function makeRow() {
    const d = document.createElement("div");
    d.className = "line";

    const wrap = document.createElement("span");
    //wrap.className = "double-wide";

    for (let i = 0; i < 40; i++) {
        const cell = document.createElement("span");
        cell.className = "cell";
        cell.textContent = " ";
        wrap.appendChild(cell);
    }

    d.appendChild(wrap);
    return d;
}

for (let i = 0; i < 24; i++) {
    const row = makeRow();
    screen.appendChild(row);
    lines.push(row);
}

const inputLine = makeRow();
inputLine.id = "input-line";
inputLine.innerHTML =
    `<span class="double-wide prompt">></span>
     <span id="input-text"></span>
     <span class="cursor"> </span>`;
screen.appendChild(inputLine);
lines.push(inputLine);

const inputText = document.getElementById("input-text");

const commandInput = document.createElement("input");
commandInput.type = "text";
commandInput.id = "command-input";
document.body.appendChild(commandInput);

/* ==================================================
   UTILITY FUNCTIONS
================================================== */
function wide(text) {
    const span = document.createElement("span");
    span.className = "double-wide";
    span.textContent = text;
    return span;
}

function nextLine() {
    cursorX = 0;
    cursorY++;
    if (cursorY > 23) {
        const removed = lines.shift();
        if (removed !== inputLine) screen.removeChild(removed);
        const newRow = makeRow();
        screen.insertBefore(newRow, inputLine);
        lines.splice(23, 0, newRow);
        cursorY = 23;
    }
}

function LOCATE(x, y) {
    cursorX = Math.max(0, Math.min(39, parseInt(x)));
    cursorY = Math.max(0, Math.min(23, parseInt(y)));
}

function getColor(n) {
    const table = {
        0:"#000000", // black
        1:"#ffffff", // white
        2:"#808080", // gray
        3:"#659BDF", // mid light blue
        4:"#a9a9a9", // dark gray
        7:"#c0c0c0", // silver
        8:"#dda0dd", // plum
        9:"#ee82ee", // violet
        10:"#ff0000", // red
        11:"#ffa500", // orange
        12:"#ffff00", // yellow
        13:"#008000", // green
        14:"#0000ff", // blue
        15:"#4b0082", // indigo
        16:"#800080"  // purple
    };
    return table[n] || "#ffffff";
}

function COLOR(fg, bg) {
    if (fg !== undefined) currentFG = getColor(parseInt(fg));
    if (bg !== undefined) currentBG = getColor(parseInt(bg));
}

function echoCommand(cmd) {
    const row = lines[cursorY];
    row.innerHTML = "";
    const wrap = document.createElement("span");
    wrap.className = "double-wide";

    const promptSpan = document.createElement("span");
    promptSpan.textContent = ">";
    wrap.appendChild(promptSpan);

    const textSpan = document.createElement("span");
    textSpan.textContent = cmd;
    wrap.appendChild(textSpan);

    row.appendChild(wrap);
    nextLine();
}

function ensureRow(row) {
    if (row.firstChild && row.firstChild.classList.contains("double-wide")) {
        return row.firstChild;
    }

    const wrap = document.createElement("span");
    wrap.className = "double-wide";

    for (let i = 0; i < 40; i++) {
        const cell = document.createElement("span");
        cell.textContent = " ";
        wrap.appendChild(cell);
    }

    row.innerHTML = "";
    row.appendChild(wrap);
    return wrap;
}

let justWrapped = false;

function PUTCHAR(ch) {
    const cell = lines[cursorY].firstChild.children[cursorX];
    cell.textContent = ch;
    cell.style.color = currentFG;
    cell.style.backgroundColor = currentBG;

    cursorX++;
    if (cursorX >= 40) {
        nextLine();
        justWrapped = true;   // â† IMPORTANT
    } else {
        justWrapped = false;
    }
}

/* ==================================================
   PRINT WITH WRAPPING + COLORS + ONE DOUBLE-WIDE WRAPPER
================================================== */
function softNewLine() {
    cursorX = 0;
    cursorY++;
    if (cursorY > 23) {
        screen.removeChild(lines.shift());
        const r = makeRow();
        screen.insertBefore(r, inputLine);
        lines.splice(23, 0, r);
        cursorY = 23;
    }
}

async function parseAndPrint(text, slow = false, delay = 0) {
    let i = 0;
    const colorRegex = /^\[C\s*(\d+)\s*,\s*(\d+)\s*\]/;

    while (i < text.length) {

        if (text[i] === "\r") {
            i++;
            continue;
        }

        if (text[i] === "\n") {
            // ğŸ”´ KEY FIX:
            // If we JUST wrapped, this newline is redundant
            if (!justWrapped) {
                nextLine();
            }
            justWrapped = false;
            i++;
            continue;
        }

        if (text[i] === "[") {
            const m = text.slice(i).match(colorRegex);
            if (m) {
                COLOR(+m[1], +m[2]);
                i += m[0].length; // zero-width
                continue;
            }
        }

        PUTCHAR(text[i]);
        i++;

        if (slow) await new Promise(r => setTimeout(r, delay));
    }
}

async function PRINT(text = "") {
    text = String(text);

    await parseAndPrint(text);

    // Only add a newline if the text did NOT already end with one
    if (!text.endsWith("\n")) {
        nextLine();
    }
}


function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function OUCH() {
    PRINT("OUCH, DONT PEEK AND POKE ME LIKE THAT!");
}

function PEEK(n) {
    OUCH();
    if(n==42) {
        return "You know hte meaning of life.";
    }
    return "Easter egg";
}

function POKE(n,n2) {
    OUCH();
}


async function SLOWPRINT(text = "", time_ms = 50) {
    text = String(text);
    await parseAndPrint(text, true, time_ms);
}

function GOTO_INPUT_LINE() {
    cursorX = 0;
    cursorY = lines.length - 2;
}

/* ==================================================
   REAL INPUT()
================================================== */
commandInput.addEventListener("input", () => {
    inputText.textContent = commandInput.value;
});

function INPUT(promptText = "") {
    return new Promise(resolve => {

        if (promptText)
            PRINT(promptText);

        commandInput.value = "";
        inputText.textContent = "";

        inputMode = resolve;

        commandInput.focus();
    });
}
/**
 * Retrieves a text file from a URL.
 * @param {string} url The URL of the text file.
 * @returns {Promise<string>} A promise that resolves to the text content of the file.
 */
/*
 async function CURL(url) {
  try {
    // Fetch the resource from the network.
    const response = await fetch(url);

    // Check if the request was successful. The fetch() function does not
    // throw an error for HTTP error statuses (like 404), so we check manually.
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // Read the response body as plain text and return the string.
    const textData = await response.text();
    return textData;

  } catch (error) {
    // Handle any errors that occurred during the fetch operation or in the processing.
    console.error("Error fetching the text file:", error);
    // You might want to return an empty string or re-throw the error,
    // depending on how you want to handle failures in your application.
    throw error;
  }
}
*/

/**
 * Performs an HTTP POST request to a URL, sending data as a URL-encoded string.
 * This function is asynchronous and will wait (when used with 'await') until the request is sent,
 * the response is received, and then return the response text.
 * @param {string} url The URL for the request.
 * @param {Object} [options={}] Optional configuration for the request.
 * @param {string} [options.data=null] The request data as a URL-encoded string (e.g., 'param1=value1&param2=value2').
 * @param {Object} [options.headers={}] Additional headers to include.
 * @returns {Promise<string>} A promise that resolves to the text content of the response.
 */
 async function CURL(url, options = {}) {
  try {
    const {
      data = null,
      headers = {},
      ...rest // Allow other fetch options if needed
    } = options;

    let fetchBody = null;
    let fetchHeaders = { ...headers };

    // For POST, set data as body with URL-encoded content type
    if (data) {
      fetchBody = data;
      if (!fetchHeaders['Content-Type']) {
        fetchHeaders['Content-Type'] = 'application/x-www-form-urlencoded';
      }
    }

    // Fetch the resource with POST method
    // This line will wait until the response is received
    const response = await fetch(url, {
      method: 'POST',
      body: fetchBody,
      headers: fetchHeaders,
      ...rest
    });

    // Check if the request was successful
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // Read the response body as plain text
    // This will also wait until the text is fully read
    const textData = await response.text();

    // Return the response text
    return textData;
  } catch (error) {
    // Handle any errors that occurred during the fetch operation or in the processing
    console.error("Error in CURL operation:", error);
    throw error;
  }
}

// Usage Examples:

// To use it in an async context and wait for the response:
async function eu() { //exampleUsage
  try {
     // POST request with URL-encoded data string
    const response2 = await CURL('https://example.com/apiendpoint', {
      data: 'param1=value1&param2=value2',
      //headers: { 'Authorization': 'Bearer your-token' }
    });
    console.log('POST response:', response2);
  } catch (error) {
    console.error('Error:', error);
  }
}


//ATDT+15593278
function preprocess(code) {
    code=code.replace(
        /=\s*INPUT\s*\(/g,
        '= await INPUT('
    );
    code = code.replace(
    /ATDT\+15593278/g, 
    'JPLYEN()');
    code = code.replace(
    /ATDT\+815593278/g, 
    'JPLYJP()');
    code = code.replace(
    /ATDT\+525593278/g, 
    'JPLYES()');
    return code;
}
//LOAD("alert('test');");

async function LOAD(program) {
    code=preprocess(program);
    try {
        let result = await window.eval(`(async()=>{ ${code} })()`);
        if (result !== undefined) PRINT(result);
    } catch (err) {
        PRINT("?SYNTAX  ERROR:"+err.message);
    }

    GOTO_INPUT_LINE()
    PRINT("READY.");
    //*commandInput.focus();
}

//OPENURLCONFIRM("https://google.com");
//test injection
//OPENURLCONFIRM("';alert(\"t\")'");
function OPENURLCONFIRM(url) {
    // Basic sanitization: ensure it starts with http:// or https://
    if (!/^https?:\/\//i.test(url)) {
        alert("Invalid URL: must start with http:// or https://");
        return;
    }

    const confirmed = confirm(
        "YOU ARE SURE YOU WANT TO LOAD THIS URL?\n\n" +
        url + "\n\n" +
        "ARE YOU SURE YOU WANT TO CONTINUE?"
    );

    if (confirmed) {
        window.open(url, '_blank');
    }
}
//LOADCONFIRM("alert('test');");
function LOADCONFIRM(program) {
    pre=""
    pre+="PRINT('*YOU ARE ABOUT TO LOAD A PROGRAM!*,\\n');"
    pre+="PRINT('ARE YOU SURE YOU WANT TO CONTINUE? Y/N\\n');"
    pre+="response = INPUT();"
    pre+="response = response.toUpperCase();"
    pre+="if(response=='Y') {"
    pre+=program
    pre+="}"    
    LOAD(pre);
}
/* ==================================================
   MAIN KEYDOWN HANDLER
================================================== */
commandInput.addEventListener("keydown", async (e) => {

    if (e.key !== "Enter") return;

    const typed = commandInput.value.trim();

    // Safari-safe modem busy detection
    // --- VALID DIAL NUMBERS ---
    const validATDT = new Set([
        "ATDT+15593278",
        "ATDT+815593278",
        "ATDT+525593278"
    ]);

    // --- INVALID ATDT â†’ BUSY TONE (Safari-safe) ---
    if (typed.startsWith("ATDT+") && !validATDT.has(typed)) {
        await PLAY("audio/busy.mp3");
        GOTO_INPUT_LINE();
        PRINT("NO CARRIER");
        return;
    }
    if (inputMode) {
        if(echo) {
            echoCommand(typed);
        }
        const resolver = inputMode;
        inputMode = null;
        commandInput.value = "";
        inputText.textContent = "";
        resolver(typed);
        return;
    }

    if (typed === "") {
        commandInput.value = "";
        inputText.textContent = "";
        return;
    }
    if(echo) {
        echoCommand(typed);
    }

    commandInput.value = "";
    inputText.textContent = "";
    code=preprocess(typed);
    try {
        let result = await eval(`(async()=>{ ${code} })()`);
        if (result !== undefined) PRINT(result);
    } catch (err) {
        if (err.message.startsWith("ATDT")) {
            PLAY("audio/busy.mp3");
            return;
        }

        PRINT("?SYNTAX  ERROR:"+err.message);
    }

    GOTO_INPUT_LINE()
    PRINT("READY.");
    //*commandInput.focus();
});
function splitStringEvery40(inputString) {
    const result = [];

    // Normalize newlines (just in case)
    const lines = String(inputString).replace(/\r/g, "").split("\n");

    for (const line of lines) {

        // Empty line â†’ keep it
        if (line.length === 0) {
            result.push("");
            continue;
        }

        // Split long lines into 40-char chunks
        for (let i = 0; i < line.length; i += 40) {
            result.push(line.slice(i, i + 40));
        }
    }

    return result;
}
/*
test more

ECHOOFF();
A = await CURL("https://amjp.psy-k.org/JPLY_BBS/utf8-art/JPLY_BBS/proxy.php?url=https://amjp.psy-k.org/JPLY_BBS/utf8-art/JPLY_BBS/3pagetamplate.txt");
MORE(A);
*/

async function MORE(text) {
    const arr = splitStringEvery40(text);
    const PAGE_LINES = 22; // visible text rows (24th is input)
    lineCounter=0;
    for (const line of arr) {

        // If screen is full, pause
        if (lineCounter >= PAGE_LINES) {
            await SLOWPRINT("************ PRESS ENTER ************\n", 2);
            await INPUT();
            lineCounter=0;
            //cursorY = 0; // reset logical page
        }

        await SLOWPRINT(line + "\n", 2);
        lineCounter++;
    }
}
// add HELP() function
async function HELP() {
    ECHOOFF();
    A = await CURL("https://amjp.psy-k.org/JPLY_BBS/utf8-art/JPLY_BBS/proxy.php?url=https://amjp.psy-k.org/JPLY_BBS/utf8-art/JPLY_BBS/helpEN.txt");
    MORE(A);
}
/* ==================================================
   BOOT SCREEN
================================================== */
LOCATE(0,0);
PRINT("**** JPLY C64 SailorMuulator ****\n");
PRINT("**** JS_BASIC V-A.03         ****\n");
PRINT("\n");
PRINT("---------------------------------\n");
PRINT("TYPE HELP() THEN PRESS [ENTER]\n");
PRINT("HELPJP()ã‚’æ‰“ã£ã¦ã€[ENTER]ã‚’æŠ¼ã—ã¦\n");
PRINT("ESCRIBA HELPES() Y PRESIONE [ENTER]\n");
PRINT("\n");
PRINT("ATM0 - MUTE ãƒŸãƒ¥ãƒ¼ãƒˆ SILENCIAR\n");
PRINT("ATDT+15593278  - ENGLISH JPLY BBS\n");
PRINT("ATDT+815593278 - JPLY BSSã€€æ—¥æœ¬èª\n");
PRINT("ATDT+525593278 - JPLY BBS ESPAÃ‘OL\n");
PRINT("PLEASE USE ALLCAPS FOR COMMANDS,\n");
PRINT("PRESS ENTER WHEN DONE.\n");
if(isMobile) {
    PRINT("FOR BEST RESULTS ON MOBILE,\n");
    PRINT("WE RECOMMEND USING A\n");
    PRINT("BLUETOOTH PHYSICAL KEYBOARD\n");
}
PRINT("\n");
PRINT("READY.\n");
//for (let i = 0; i < 17; i++) PRINT("");

document.addEventListener("click", () => commandInput.focus());
//*commandInput.focus();
function JPLYEN() {
    translate = i18n_setlang("English");
    prg=""
    prg+="ECHOOFF();"
    prg+="PRINT('CONNECTING...');"
    prg+="await PLAY('audio/modem.mp3');"
    prg+="A = await CURL('https://amjp.psy-k.org/JPLY_BBS/scripts/proxy.php?url=https://amjp.psy-k.org/JPLY_BBS/scripts/login.JS_BASIC');"
    prg+="LOAD(A);"
    LOAD(prg);
}
function JPLYJP() {
    translate = i18n_setlang("Japanese");
    prg=""
    prg+="ECHOOFF();"
    prg+="PRINT('æ¥ç¶šä¸­...');"
    prg+="await PLAY('audio/modem.mp3');"
    prg+="A = await CURL('https://amjp.psy-k.org/JPLY_BBS/scripts/proxy.php?url=https://amjp.psy-k.org/JPLY_BBS/scripts/login.JS_BASIC');"
    prg+="LOAD(A);"
    LOAD(prg);
}
function JPLYES() {
    translate = i18n_setlang("Spanish");
    prg=""
    prg+="ECHOOFF();"
    prg+="PRINT('CONECTANDO...');"
    prg+="await PLAY('audio/modem.mp3');"
    prg+="A = await CURL('https://amjp.psy-k.org/JPLY_BBS/scripts/proxy.php?url=https://amjp.psy-k.org/JPLY_BBS/scripts/login.JS_BASIC');"
    prg+="LOAD(A);"
    LOAD(prg);
}

/*
test input and locate 

ECHOOFF();
PRINT("ENTER NAME:");
A = await INPUT();
PRINT("HELLO " + A);
AGE = INPUT("AGE?");
PRINT("YOU ARE " + AGE + " YEARS OLD");
LOCATE(5,5);
PRINT("HELLO");
LOCATE(5,5);
PRINT("A");

oneliner
ECHOOFF(); PRINT("ENTER NAME:"); A =INPUT(); PRINT("HELLO " + A); AGE = INPUT("AGE?"); PRINT("YOU ARE " + AGE + " YEARS OLD"); LOCATE(5,5); PRINT("HELLO"); LOCATE(5,5); PRINT("A");


test UTF8ART art

ECHOOFF();
COLOR(0,10);LOCATE(0,0);
JPLYBBS =  '';
JPLYBBS += 'â£Ÿâ£™â£¿â¡Ÿâ ›â ›â ›â ›â »â ¿â Ÿâ ™â šâ ‘â â¢»â£™â£›â Šâ ³â ›â ›â ›â¢›â¡‘â â ¿â ¿â¢›â¡—â£‹â£›â ¿â ¿â »â ¹â šâ¡“â£‹â£»';
JPLYBBS += 'â¡¿â¡¿â£¹â §â¢¸â ‰â ‰â ‰â£·â¡â ‰â ‰â ‰â ‰â ‰â ¿â ­â ©â¢¸â ‰â ‰â ‰â¢¹â£®â ‡â£¿â ‰â ©â §â¡µâ ‡â£¯â¢¸â ‰â ‰â¢¹â£â¢·â¡Ÿâ£¿';
JPLYBBS += 'â §â ¯â ¥â „â¢¸â €â €â €â£¿â¡‡â €â €â €â£€â €â €â €â ‰â£¾â €â €â €â¢¸â£¿â£·â£¿â¡€â €â €â ‰â£¶â£¸â ‰â €â €â¢¸â£¿â£¿â£­â ­';
JPLYBBS += 'â£šâ£¿â¢»â¡â¢¸â €â €â €â£¿â¡‡â €â €â €â ¿â ’â €â €â €â£¿â €â €â €â¢¸â£¿â£¿â£¿â£§â¢ â €â €â ‰â ‰â €â¢ â €â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â¡Šâ£¿â ›â ›â šâ €â €â €â£¿â¡‡â €â €â €â£€â£€â£€â£¤â£·â£¿â €â €â €â ˜â ›â ›â ›â¢»â£¼â¡¶â €â €â €â¢¸â¢¸â£¿â£¿â£¿â£¿â£¿â£§';
JPLYBBS += 'â¡…â£¿â¡€â €â €â €â €â£¤â£¿â¡‡â €â €â¢€â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â €â €â €â €â¢¸â£¿â£§â €â €â €â¢¸â¢¸â£¿â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â â¡‹â¢™â¡‡â €â¡‡â£¿â£¿â£¿â£§â£‡â¡‡â¢¸â£¿â£¿â£¿â¡Ÿâ£¿â¢¹â¡€â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â¡‡â¢¸â¢¸â£¿â£¿â£¿â ¿â ¿â ¿â Ÿ';
JPLYBBS += 'â¡›â£½â£¿â£·â¡‚â£“â£¿â£¿â¡â ‰â ‰â â ˆâ ‰â ™â ¿â¡â£¿â ‰â ‰â ‰â ‰â ‰â ™â ›â¢¿â£¿â£¿â¡¿â ‰â €â €â ˆâ ‰â ™â¢¯â¢©â¡â£¥â£­';
JPLYBBS += 'â¢Ÿâ£™â¢›â£›â£›â£›â£›â£›â¡‡â €â €â¢ â£¤â¡„â €â €â €â£¿â €â €â €â£¤â£¤â €â €â €â¢¸â €â €â €â£¤â£¶â£¤â¡€â£¶â£¿â£¿â£–â£§â£¿';
JPLYBBS += 'â£­â£¿â£¿â£¿â£·â£·â¢¿â£¿â¡‡â €â €â ˆâ ‰â â €â£¤â£¿â£¿â €â €â €â ‰â ‰â €â¢ â£¾â£¿â €â €â €â ˆâ ‰â ‰â ¿â¢¿â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â£¿â¢¿â£¿â£¿â£â£¿â£¿â¢¿â¡‡â €â €â¢°â£¶â¡†â €â €â ‰â£¿â €â €â €â£¶â£¶â €â €â €â¢¹â£¶â¡‡â£„â£€â£€â¡€â €â €â¢¸â£¿â£»â£¿â£¿';
JPLYBBS += 'â£¼â£¶â£šâ£»â£¿â£·â£¯â£¶â¡‡â €â €â ˆâ ‰â â €â €â£ â£¿â €â €â €â ‰â ‰â €â €â¢€â£¸â£¿â ›â ‰â ›â ›â ƒâ €â €â£¸â£¿â£¿â£Ÿâ£›';
JPLYBBS += 'â ­â£¶â£¶â£–â¡¶â ¶â¡–â£²â¡‡â£¤â €â£¤â£¤â£¤â£´â£¿â£¿â£¿â €â£¤â €â£¤â£¤â£¤â£¼â£¿â£¿â£â¡„â €â¡€â¢€â¡€â£„â£¿â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â£¿â¢©â£­â ½â¡¿â ¿â ¿â£¿â¡‡â ¸â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¶â£¿â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €â ƒâ¢¸â£·â£¿â£¿â£¿â£¿â¡¿â£â£¿';
JPLYBBS += 'â£¿â£¿â£¿â£§â£¿â£·â£·â£¿â£½â â €â£¯â£¿â£¿â£¯â¢¿â ¿â¡¿â£¾â â €â¢½â£¿â¢¿â ¿â¢½â£¿â£¿â ¿â ¿â ‡â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿';
JPLYBBS += 'â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢€â£¿â£¿â£¿â£¿â£¾â¡¿â£¿â£¿â¢¿â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢¿â£¿â¡‡â¢¸â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¾â£¿â£¿â£¿â£¿â£¯â£¿â£·â£¶â£¶â£¿â£¿â£¾â£¾â£¿â£¿â£¿â£¿â£¶â£¿â£·â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿';
PRINT(JPLYBBS);


onelienr
ECHOOFF();COLOR(0,10);LOCATE(0,0);JPLYBBS =  '';JPLYBBS += 'â£Ÿâ£™â£¿â¡Ÿâ ›â ›â ›â ›â »â ¿â Ÿâ ™â šâ ‘â â¢»â£™â£›â Šâ ³â ›â ›â ›â¢›â¡‘â â ¿â ¿â¢›â¡—â£‹â£›â ¿â ¿â »â ¹â šâ¡“â£‹â£»';JPLYBBS += 'â¡¿â¡¿â£¹â §â¢¸â ‰â ‰â ‰â£·â¡â ‰â ‰â ‰â ‰â ‰â ¿â ­â ©â¢¸â ‰â ‰â ‰â¢¹â£®â ‡â£¿â ‰â ©â §â¡µâ ‡â£¯â¢¸â ‰â ‰â¢¹â£â¢·â¡Ÿâ£¿';JPLYBBS += 'â §â ¯â ¥â „â¢¸â €â €â €â£¿â¡‡â €â €â €â£€â €â €â €â ‰â£¾â €â €â €â¢¸â£¿â£·â£¿â¡€â €â €â ‰â£¶â£¸â ‰â €â €â¢¸â£¿â£¿â£­â ­';JPLYBBS += 'â£šâ£¿â¢»â¡â¢¸â €â €â €â£¿â¡‡â €â €â €â ¿â ’â €â €â €â£¿â €â €â €â¢¸â£¿â£¿â£¿â£§â¢ â €â €â ‰â ‰â €â¢ â €â£¿â£¿â£¿â£¿â£¿';JPLYBBS += 'â¡Šâ£¿â ›â ›â šâ €â €â €â£¿â¡‡â €â €â €â£€â£€â£€â£¤â£·â£¿â €â €â €â ˜â ›â ›â ›â¢»â£¼â¡¶â €â €â €â¢¸â¢¸â£¿â£¿â£¿â£¿â£¿â£§';JPLYBBS += 'â¡…â£¿â¡€â €â €â €â €â£¤â£¿â¡‡â €â €â¢€â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â €â €â €â €â¢¸â£¿â£§â €â €â €â¢¸â¢¸â£¿â£¿â£¿â£¿â£¿â£¿';JPLYBBS += 'â â¡‹â¢™â¡‡â €â¡‡â£¿â£¿â£¿â£§â£‡â¡‡â¢¸â£¿â£¿â£¿â¡Ÿâ£¿â¢¹â¡€â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â¡‡â¢¸â¢¸â£¿â£¿â£¿â ¿â ¿â ¿â Ÿ';JPLYBBS += 'â¡›â£½â£¿â£·â¡‚â£“â£¿â£¿â¡â ‰â ‰â â ˆâ ‰â ™â ¿â¡â£¿â ‰â ‰â ‰â ‰â ‰â ™â ›â¢¿â£¿â£¿â¡¿â ‰â €â €â ˆâ ‰â ™â¢¯â¢©â¡â£¥â£­';JPLYBBS += 'â¢Ÿâ£™â¢›â£›â£›â£›â£›â£›â¡‡â €â €â¢ â£¤â¡„â €â €â €â£¿â €â €â €â£¤â£¤â €â €â €â¢¸â €â €â €â£¤â£¶â£¤â¡€â£¶â£¿â£¿â£–â£§â£¿';JPLYBBS += 'â£­â£¿â£¿â£¿â£·â£·â¢¿â£¿â¡‡â €â €â ˆâ ‰â â €â£¤â£¿â£¿â €â €â €â ‰â ‰â €â¢ â£¾â£¿â €â €â €â ˆâ ‰â ‰â ¿â¢¿â£¿â£¿â£¿â£¿â£¿';JPLYBBS += 'â£¿â¢¿â£¿â£¿â£â£¿â£¿â¢¿â¡‡â €â €â¢°â£¶â¡†â €â €â ‰â£¿â €â €â €â£¶â£¶â €â €â €â¢¹â£¶â¡‡â£„â£€â£€â¡€â €â €â¢¸â£¿â£»â£¿â£¿';JPLYBBS += 'â£¼â£¶â£šâ£»â£¿â£·â£¯â£¶â¡‡â €â €â ˆâ ‰â â €â €â£ â£¿â €â €â €â ‰â ‰â €â €â¢€â£¸â£¿â ›â ‰â ›â ›â ƒâ €â €â£¸â£¿â£¿â£Ÿâ£›';JPLYBBS += 'â ­â£¶â£¶â£–â¡¶â ¶â¡–â£²â¡‡â£¤â €â£¤â£¤â£¤â£´â£¿â£¿â£¿â €â£¤â €â£¤â£¤â£¤â£¼â£¿â£¿â£â¡„â €â¡€â¢€â¡€â£„â£¿â£¿â£¿â£¿â£¿â£¿';JPLYBBS += 'â£¿â¢©â£­â ½â¡¿â ¿â ¿â£¿â¡‡â ¸â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¶â£¿â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €â ƒâ¢¸â£·â£¿â£¿â£¿â£¿â¡¿â£â£¿';JPLYBBS += 'â£¿â£¿â£¿â£§â£¿â£·â£·â£¿â£½â â €â£¯â£¿â£¿â£¯â¢¿â ¿â¡¿â£¾â â €â¢½â£¿â¢¿â ¿â¢½â£¿â£¿â ¿â ¿â ‡â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿';JPLYBBS += 'â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢€â£¿â£¿â£¿â£¿â£¾â¡¿â£¿â£¿â¢¿â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢¿â£¿â¡‡â¢¸â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿';JPLYBBS += 'â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¾â£¿â£¿â£¿â£¿â£¯â£¿â£·â£¶â£¶â£¿â£¿â£¾â£¾â£¿â£¿â£¿â£¿â£¶â£¿â£·â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿';PRINT(JPLYBBS);

//test colors

COLOR(10,0);
PRINT("RED ON BLACK");
COLOR(1,4);
PRINT("WHITE ON DARK GRAY");
COLOR(14,1);
PRINT("BLUE ON WHITE");

oneliner
COLOR(10,0);PRINT("RED ON BLACK");COLOR(1,4);PRINT("WHITE ON DARK GRAY");COLOR(14,1);PRINT("BLUE ON WHITE");

test Japanese

PRINT("æ—¥æœ¬èª");

test 40 col

PRINT("012345678901234567890123456789012345678901")


test PLAY

PRINT("now playing");
PLAY("audio/modem.mp3");
PRINT("Ended playing");

test slowprint progra

ECHOOFF();
JPLYBBS =  '';
JPLYBBS += 'â£Ÿâ£™â£¿â¡Ÿâ ›â ›â ›â ›â »â ¿â Ÿâ ™â šâ ‘â â¢»â£™â£›â Šâ ³â ›â ›â ›â¢›â¡‘â â ¿â ¿â¢›â¡—â£‹â£›â ¿â ¿â »â ¹â šâ¡“â£‹â£»';
JPLYBBS += 'â¡¿â¡¿â£¹â §â¢¸â ‰â ‰â ‰â£·â¡â ‰â ‰â ‰â ‰â ‰â ¿â ­â ©â¢¸â ‰â ‰â ‰â¢¹â£®â ‡â£¿â ‰â ©â §â¡µâ ‡â£¯â¢¸â ‰â ‰â¢¹â£â¢·â¡Ÿâ£¿';
JPLYBBS += 'â §â ¯â ¥â „â¢¸â €â €â €â£¿â¡‡â €â €â €â£€â €â €â €â ‰â£¾â €â €â €â¢¸â£¿â£·â£¿â¡€â €â €â ‰â£¶â£¸â ‰â €â €â¢¸â£¿â£¿â£­â ­';
JPLYBBS += 'â£šâ£¿â¢»â¡â¢¸â €â €â €â£¿â¡‡â €â €â €â ¿â ’â €â €â €â£¿â €â €â €â¢¸â£¿â£¿â£¿â£§â¢ â €â €â ‰â ‰â €â¢ â €â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â¡Šâ£¿â ›â ›â šâ €â €â €â£¿â¡‡â €â €â €â£€â£€â£€â£¤â£·â£¿â €â €â €â ˜â ›â ›â ›â¢»â£¼â¡¶â €â €â €â¢¸â¢¸â£¿â£¿â£¿â£¿â£¿â£§';
JPLYBBS += 'â¡…â£¿â¡€â €â €â €â €â£¤â£¿â¡‡â €â €â¢€â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â €â €â €â €â¢¸â£¿â£§â €â €â €â¢¸â¢¸â£¿â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â â¡‹â¢™â¡‡â €â¡‡â£¿â£¿â£¿â£§â£‡â¡‡â¢¸â£¿â£¿â£¿â¡Ÿâ£¿â¢¹â¡€â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â¡‡â¢¸â¢¸â£¿â£¿â£¿â ¿â ¿â ¿â Ÿ';
JPLYBBS += 'â¡›â£½â£¿â£·â¡‚â£“â£¿â£¿â¡â ‰â ‰â â ˆâ ‰â ™â ¿â¡â£¿â ‰â ‰â ‰â ‰â ‰â ™â ›â¢¿â£¿â£¿â¡¿â ‰â €â €â ˆâ ‰â ™â¢¯â¢©â¡â£¥â£­';
JPLYBBS += 'â¢Ÿâ£™â¢›â£›â£›â£›â£›â£›â¡‡â €â €â¢ â£¤â¡„â €â €â €â£¿â €â €â €â£¤â£¤â €â €â €â¢¸â €â €â €â£¤â£¶â£¤â¡€â£¶â£¿â£¿â£–â£§â£¿';
JPLYBBS += 'â£­â£¿â£¿â£¿â£·â£·â¢¿â£¿â¡‡â €â €â ˆâ ‰â â €â£¤â£¿â£¿â €â €â €â ‰â ‰â €â¢ â£¾â£¿â €â €â €â ˆâ ‰â ‰â ¿â¢¿â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â£¿â¢¿â£¿â£¿â£â£¿â£¿â¢¿â¡‡â €â €â¢°â£¶â¡†â €â €â ‰â£¿â €â €â €â£¶â£¶â €â €â €â¢¹â£¶â¡‡â£„â£€â£€â¡€â €â €â¢¸â£¿â£»â£¿â£¿';
JPLYBBS += 'â£¼â£¶â£šâ£»â£¿â£·â£¯â£¶â¡‡â €â €â ˆâ ‰â â €â €â£ â£¿â €â €â €â ‰â ‰â €â €â¢€â£¸â£¿â ›â ‰â ›â ›â ƒâ €â €â£¸â£¿â£¿â£Ÿâ£›';
JPLYBBS += 'â ­â£¶â£¶â£–â¡¶â ¶â¡–â£²â¡‡â£¤â €â£¤â£¤â£¤â£´â£¿â£¿â£¿â €â£¤â €â£¤â£¤â£¤â£¼â£¿â£¿â£â¡„â €â¡€â¢€â¡€â£„â£¿â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â£¿â¢©â£­â ½â¡¿â ¿â ¿â£¿â¡‡â ¸â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¶â£¿â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €â ƒâ¢¸â£·â£¿â£¿â£¿â£¿â¡¿â£â£¿';
JPLYBBS += 'â£¿â£¿â£¿â£§â£¿â£·â£·â£¿â£½â â €â£¯â£¿â£¿â£¯â¢¿â ¿â¡¿â£¾â â €â¢½â£¿â¢¿â ¿â¢½â£¿â£¿â ¿â ¿â ‡â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿';
JPLYBBS += 'â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢€â£¿â£¿â£¿â£¿â£¾â¡¿â£¿â£¿â¢¿â €â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢¿â£¿â¡‡â¢¸â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿';
JPLYBBS += 'â£¿â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¾â£¿â£¿â£¿â£¿â£¯â£¿â£·â£¶â£¶â£¿â£¿â£¾â£¾â£¿â£¿â£¿â£¿â£¶â£¿â£·â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿';

COLOR(0,10);LOCATE(0,0);
await SLOWPRINT("2400    bps     4.17ms  1984",4.17);
PRINT("");
await SLOWPRINT(JPLYBBS,4.17);

COLOR(0,9);LOCATE(0,0);
await SLOWPRINT("14.4    kbps    2ms     1991",2);
PRINT("");
await SLOWPRINT(JPLYBBS,2);

COLOR(0,8);LOCATE(0,0);
await SLOWPRINT("56      kbps    0.69ms  1998",0.69);
PRINT("");
await SLOWPRINT(JPLYBBS,0.69);

COLOR(0,7);LOCATE(0,0);
await SLOWPRINT("110     bps     90.9ms  1950",90.9);
PRINT("");
await SLOWPRINT(JPLYBBS,90.9);


modem speeds
110     bps     90.9ms  1950
2400    bps     4.17ms  1984
14.4    kbps    2ms     1991
56      kbps    0.69ms  1998

ECHOOFF();
COLOR(0,10);LOCATE(0,0);
JPLYBBS =  '';
JPLYBBS += 'â£Ÿâ£™â£¿â¡Ÿâ ›â ›â ›â ›â »â ¿â Ÿâ ™â šâ ‘â â¢»â£™â£›â Šâ ³â ›â ›â ›â¢›â¡‘â â ¿â ¿â¢›â¡—â£‹â£›â ¿â ¿â »â ¹â šâ¡“â£‹â£»';
JPLYBBS += 'â£Ÿâ£™â£¿â¡Ÿâ ›';
SLOWPRINT(JPLYBBS,30);


test CURL program

ECHOOFF();
A = await CURL("https://amjp.psy-k.org/JPLY_BBS/utf8-art/JPLY_BBS/proxy.php?url=https://amjp.psy-k.org/JPLY_BBS/utf8-art/JPLY_BBS/JPLY_BBS_LOGIN_SCREEN1BW.txt");
PRINT(A);

test with color
(fixed, actually the font size on vscode is not very accurate eventho it is set to monospace)bug, stll a few characters seem to be off at the end of the print
remember, you need to test it with the version on hte server, otherwise you will get an error of failed to fetch

ECHOOFF();
A = await CURL("https://amjp.psy-k.org/JPLY_BBS/utf8-art/JPLY_BBS/proxy.php?url=https://amjp.psy-k.org/JPLY_BBS/utf8-art/JPLY_BBS/modem_speed_menu.txt");
PRINT(A);

test scriptloading

ECHOOFF();
A = await CURL("https://amjp.psy-k.org/JPLY_BBS/scripts/proxy.php?url=https://amjp.psy-k.org/JPLY_BBS/scripts/login.JS_BASIC");
LOAD(A);

//did not need this line at all//A = A.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

testing i18n

translate = i18n_setlang("Japanese");
PRINT(translate["Hello World"]);


test POST

var response = await CURL('https://amjp.psy-k.org/JPLY_BBS/server_side/register.php', {
  data: 'nick=amigojapan&pw=mockpassword&email=mockemail@email.com'
});
PRINT(response);

test if is logged in

var response = await CURL('https://amjp.psy-k.org/JPLY_BBS/server_side/is_loged_in.php', {
  data: 'nick=test&pw=test&email=test'
});
PRINT(response);



todo list
//(fixed)bug seems it is not creating a newline when it reacher the end of hte width of the screen.
(done)add the COLOR(foregroudcolor,backroudcolor) command that takes numbers form getColor(colorNumber) by passing numbers as foreground and background colors, one it is called future print statements should use these foreground and background colors for the text being printed
(done)LOAD()
bug help appears as help in safai only, dont have a mac to test it, cant fix it
bug LOADCONFIRM() prints ready before the program execution ends
FIX cursor problem with non moving cursor
try changing all text to double width characters, like i did with the english in otherworld frontierã€€
maybe try inverting the behavious of capslock? KeyboardEvent.getModifierState('CapsLock')//return ture if capslock is on
maybe add *optional* CRT effect with something like this https://github.com/D3nn7/crt-css?tab=readme-ov-file

TYPE REGISTER OR ENTER USERNAME:
ã€Œãƒ¦ãƒ¼ã‚¶ç™»éŒ²ã€ã‚‚ã—ãã¯ãƒãƒ³ãƒ‰ãƒ«ã‚’å…¥åŠ›ï¼š
ESCRIBA REGISTRAT O PONGA SU NOMBRE DE USUARIO]:

PASSWORD:
ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼›
CONTRASEÃ‘A:



registration

get user IP and IMEI if possible
block TOR, nessesary to avoid evil users


NOTE;USER NAME CANNOT EASILY BE HCANGED
ENTER NEW USERNAME:
æ³¨æ„ï¼›ãƒãƒ³ãƒ‰ãƒ«åãŒã‹ã‚“ãŸã‚“ã«å¤‰ãˆã‚‰ã‚Œãªã„ã€‚
æ–°ã—ã„ãƒãƒ³ãƒ‰ãƒ«ã‚’å…¥åŠ›ï¼š
NOTA; EL NOMBRE DE USUARIO NO ES FACIL DE CAMBIAR
PONGA SU NUEVO NOMBRE DE USUARIO]:

USERNAME TAKEN
ãã®ãƒãƒ³ãƒ‰ãƒ«ã¯ã‚‚ã†æ—¢ã«å­˜åœ¨ã—ã¦ã‚‹
ESE NOMBRE DE USUARIO YA EXISTE

NEW PASSWORD:
æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼›
NUEVA CONTRASEÃ‘A:

CONFIRM PASSWORD:
ã‚‚ã†ä¸€åº¦ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼›
CONFIRMAR CONTRASEÃ‘A:


PASSWORD MISMATCH!
ä¸€è‡´ã—ãªã„!
LAS 2 CONTRASEÃ‘AS NO SON IGUALES!


WELCOME! PLEASE READ RULES
ã‚ˆã†ã“ãï¼ãƒ«ãƒ¼ãƒ«ã‚’èª­ã‚“ã§ã­ï¼
BIENVENID(O/A)! PORFAVOR LEE LAS REGLAS


add rules option to main menu 
add a bit of syntax sugar so it can be used more like BASIC 

add:
TYPE HELP() FOR HELP THEN PRESS [ENTER]
TYPE HELPJP()ã‚’æ‰“ã£ã¦ãã—ã¦[ENTER]ã‚’æŠ¼ã—ã¦ã€æ—¥æœ¬èªã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã—ã¾ã™
ESCRIBA HELPES() Y PRECIONE [ENTER} PARA AYUDA EN ESPAÃ‘OL

TYPE ATDT+15593278 TO CONNECT TO ENGLISH JPLY BBS
ATDT+815593278ã‚’æ‰“ã£ãŸã‚‰ã€‚JPLY BSSã®æ—¥æœ¬ç‰ˆã«å…¥ã‚Šã¾ã™
ESCRIBA ATDT+525593278 PARA CONNECTARSE A JPLY BBS EN ESPAÃ‘OL


HELP IN ENGLISH
ECHOOFF();
TURNS COMMAND ECHO OFF
ECHON();
TURNS COMMAND ECHO ON
PRINT("HELLO WORLD!:");
PRINTS HELLO WORLD!
VARNAME = INPUT()
AWAITS FOR USER TO INPUT AND PRESS ENTER, THEN STORES VALUE IN VARIABLE VARNAME
COLOR(0-15,0-15);
CHANGES THE COLOR OF THE FOREGROUND AND BACKGROUD
LOCATE(X, X)
CHANGES THE POSITION OF THE NEXT PRINT STATEMENT TO X AND Y COORDINATES
PLAY(URL);
PLAYS THE SOUND LOCATED AT STRING IN URL VARIABLE
HELP()
DISPLAYS THIS HELP SCREEN

TYPE ATDT+15593278 TO CONNECT TO ENGLISH JPLY BBS
ATDT+815593278ã‚’æ‰“ã£ãŸã‚‰ã€‚JPLY BSSã®æ—¥æœ¬ç‰ˆã«å…¥ã‚Šã¾ã™
ESCRIBA ATDT+525593278 PARA CONNECTARSE A JPLY BBS EN ESPAÃ‘OL


amigojapan> Emmanuel_Chanel: ã“ã‚“ã«ã¡ã¯
3:19 PM <amigojapan> Emmanuel_Chanel: BBSã£ã¦çŸ¥ã£ã¦ã¾ã™ã‹ï¼Ÿ
3:19 PM <Emmanuel_Chanel> ã‚¦ã‚§ãƒ–ä¸Šã®æ²ç¤ºæ¿ã‚’æ—¥æœ¬ã§ã¯ãã†å‘¼ã³ã¾ã™ã­ã€‚
3:20 PM <Emmanuel_Chanel> Bullet-in Board System ã ã‹ã®ç•¥ã§ã€‚
3:21 PM <amigojapan> Emmanuel_Chanel: ã‚¢ãƒ¡ãƒªã‚«ã«ã¯1978å¹´ã‹ã‚‰ã‚ã‚Šã¾ã—ãŸã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆä¸Šã˜ã‚ƒãªãã¦ã€ï¼˜ãƒ“ãƒƒãƒˆãƒ‘ã‚½ã‚³ãƒ³ã§ä½¿ã£ãŸ
3:21 PM <amigojapan> ã¯ã„
3:21 PM <Emmanuel_Chanel> ç¢ºã‹ã«ã€ã‚¦ã‚§ãƒ–ä¸Šã®æ²ç¤ºæ¿ã¨ã¯åˆ¥ã«ãã‚“ãªã‚·ã‚¹ãƒ†ãƒ ãŒã‚ã‚‹ã¨ã„ã†ã®ã¯ã€ç§ã‚‚å¤§å­¦ã§ç¿’ã„ã¾ã—ãŸã€‚
3:21 PM <amigojapan> ä»Šå¤ã„BBSã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½œã£ã¦ã¾ã™
3:22 PM <amigojapan> ã¸ãƒ¼
3:23 PM <amigojapan> Emmanuel_Chanel: WEBã¯1989å¹´ã§å§‹ã¾ã‚Šã¾ã—ãŸ
    amigojapan> ï¼‘ï¼‘å¹´é–“WEBã®å‰ã®BBSã‚ã‚Šã¾ã—ãŸ


JPLY BBS rules:
Please refrain from topics that contravene public order and morals.
Illegal activity prohibited.
do not post inappropriate material, no profanity, no attack other users.
be friendly with other users.
No trolling or SPAM
No talk about illegal drugs or kiken-drugs
Obey SysOp and Co-SysOps
Japanese law applies in this BBS.

JPLY BBSã®ãƒ«ãƒ¼ãƒ«ï¼š
å…¬åºè‰¯ä¿—ã«åã™ã‚‹è©±é¡Œã¯ã”é æ…®ãã ã•ã„
é•æ³•ãªè¡Œç‚ºã€ä¸é©åˆ‡ãªå†…å®¹ã®æŠ•ç¨¿ã€å‘çŒ¥ãªè¨€è‘‰ã®ä½¿ç”¨ã€ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®æ”»æ’ƒã¯ç¦æ­¢ã§ã™ã€‚
ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯å‹å¥½çš„ã«æ¥ã—ã¦ãã ã•ã„ã€‚
ã‚ã‚‰ã—ã¨ã‚¹ãƒ‘ãƒ è¡Œç‚ºã¯ç¦æ­¢ã§ã™ã€‚
é•æ³•ãªãƒ‰ãƒ©ãƒƒã‚°ã‚„å±é™ºãƒ‰ãƒ©ã‚°ã®è©±ã‚‚ç¦æ­¢
ã‚·ã‚¹ãƒ†ãƒ ã‚ªãƒšãƒ¬ã‚¿ãƒ¼é”ã«å¾“ã£ã¦ä¸‹ã•ã„ã€‚
ã“ã®BBSã¯æ—¥æœ¬æ³•å¾‹é©ç”¨ã§ã™ã€‚

Reglas del BBS JPLY:
Por favor, abstÃ©ngase de abordar temas que contravengan el orden pÃºblico y la moral.
Actividad ilegal prhoivida.
No publiques contenido inapropiado, no utilices lenguaje obseno, no ataques a otros usuarios.
SÃ© amable con los demÃ¡s usuarios.
No envÃ­es espam.
No trolear.
No hablar sobre drogas ilegales o drogas-kiken
Obedece a los Operadores del systema
Este BBS usa las leyes Japonesas

where to get all the ascii charaters for making boarders liike in Vistual BBS
https://www.ascii.ca/cp437.htm

add some upper art?
Main Menu

--Page Sysop
--Door Games(BASIC interpreter, American football, darts)
--Warez(what to put here? maybe link t JPLY games? self ad or actual ---way to download JPLY games)
--Bulletin Board(threads, posts)
--Mail
--who(list all users)
--Finger(list onlie users)
--Chat(as if it were a multi-line BBS)?
--Abour JPLY BBS
--Quit
Comment



submenues

Mail
---list
---read
---write

Bout
---revival of Mexico city BBS called Night NAK form late 80s
by same SysOp, same phone number displayed. English, Japanese
and Spanish supported.
now published as JPLY becuase that is the company I am
wokring at.
The idea is to give a taste of what BBS were like in the past
to the people who never had a chance to try the,
and also inspire the nostalgia in those who lived through
that era.

SeeRaaMuulator - is a word I just coined, which , means a software that just simulates the look and feel of something, not the actual function of the thing being simulated. SailorMulator maybe  better in English I guess? synonym: skeumorphism
SeeRaaMuulator: es una palabra que acabo de acuÃ±ar y que significa un software que simplemente simula la apariencia de algo, no la funciÃ³n real de lo que se estÃ¡ simulando. Supongo que SailorMulator tal vez sea mejor en inglÃ©s. SinÃ³nimo: esqueumorfismo
ã‚»ãƒ¼ãƒ©ãƒ¼ãƒ ãƒ¼ãƒ¬ãƒ¼ã‚¿ãƒ¼ - ã“ã‚Œã¯ç§ãŒä½œã£ãŸè¨€è‘‰ã§ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã•ã‚Œã‚‹ã‚‚ã®ã®å®Ÿéš›ã®æ©Ÿèƒ½ã§ã¯ãªãã€ä½•ã‹ã®å¤–è¦³ã¨æ„Ÿè§¦ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã ã‘ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚’æ„å‘³ã—ã¾ã™ã€‚ SailorMulator ã¯ãŠãã‚‰ãè‹±èªã®æ–¹ãŒå¾—æ„ã ã¨æ€ã„ã¾ã™ã€‚åŒç¾©èª: skeumorphism

teletext? seems to be something simillar to JPLY BBS
https://nmsceefax.co.uk/#id=WyJubXMtY2VlZmF4IiwiaW50ZXJuYWwubmF0aGFubWVkaWFzZXJ2aWNlcy5jby51ayIsIi93ZWJzb2NrZXRzL2NlZWZheCJd:page=100

Â§A resurecction of Night Nack BBSÂ§
*/
</script>
<!-- =========================================================
     MOBILE TOP PREVIEW BAR (APPEND ONLY)  âœ… WORKING VERSION
     Always visible at the TOP while typing on mobile (Android/iOS).
     Mirrors #command-input.value so you can see what you're typing.
     ========================================================= -->
     <style>
        #__topPreviewBar {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
      
          padding: 10px 12px;
          background: rgba(0,0,0,0.92);
          color: #fff;
      
          font: 16px/1.2 monospace;
          z-index: 2147483647;
      
          display: none;            /* shown only on mobile while input is active */
          pointer-events: none;
          box-sizing: border-box;
      
          border-bottom: 1px solid rgba(255,255,255,0.15);
          white-space: pre;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      
        #__topPreviewLabel { opacity: 0.7; margin-right: 8px; }
      </style>
      
      <div id="__topPreviewBar" aria-hidden="true">
        <span id="__topPreviewLabel">TYPING:</span><span id="__topPreviewText"></span>
      </div>
      
      <script>
      (function () {
        const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);
        if (!isIOS && !isAndroid) return;
      
        const commandInput = document.getElementById("command-input");
        const bar = document.getElementById("__topPreviewBar");
        const textEl = document.getElementById("__topPreviewText");
        if (!commandInput || !bar || !textEl) return;
      
        function setText() {
          const v = String(commandInput.value || "");
          textEl.textContent = v.length > 300 ? (v.slice(0, 300) + "â€¦") : v;
        }
      
        function show() {
          bar.style.display = "block";
          setText();
        }
      
        function hide() {
          bar.style.display = "none";
        }
      
        commandInput.addEventListener("focus", show);
        commandInput.addEventListener("blur", hide);
      
        commandInput.addEventListener("input", () => {
          if (bar.style.display !== "none") setText();
        });
      
        // Backup poll (works even if focus events are weird)
        setInterval(() => {
          const active = (document.activeElement === commandInput);
          if (active) {
            if (bar.style.display === "none") show();
            else setText();
          } else {
            if (bar.style.display !== "none") hide();
          }
        }, 150);
      })();
      </script>
               <!-- =========================================================
     DISMISS MOBILE KEYBOARD ON ENTER (APPEND ONLY)
     Blurs #command-input AFTER Enter is processed.
     ========================================================= -->
<script>
    (function () {
      const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);
      const isAndroid = /Android/i.test(navigator.userAgent);
      if (!isIOS && !isAndroid) return;
    
      const input = document.getElementById("command-input");
      if (!input) return;
    
      input.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;
    
        // Let your existing Enter handler run first,
        // THEN blur to dismiss the soft keyboard.
        setTimeout(() => {
          // Only blur if still focused
          if (document.activeElement === input) {
            input.blur();
          }
        }, 0);
      }, true); // capture=true so we don't interfere
    })();
    </script>
       <!-- =========================================================
     MOBILE: KEYBOARD ONLY ON TAP (APPEND ONLY)
     Blocks programmatic focus() unless it follows a user tap.
     ========================================================= -->
<script>
    (function () {
      const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);
      const isAndroid = /Android/i.test(navigator.userAgent);
      if (!isIOS && !isAndroid) return;
    
      const input = document.getElementById("command-input");
      if (!input) return;
    
      // Gate: only allow focus for a short time after a real user tap.
      let allowFocusUntil = 0;
      const ALLOW_MS = 800;
    
      function armFocusGate() {
        allowFocusUntil = Date.now() + ALLOW_MS;
        // if you want immediate keyboard on tap:
        try { input.focus({ preventScroll: true }); } catch { input.focus(); }
      }
    
      // Any tap on the screen should bring up the keyboard (and allow focus briefly)
      document.addEventListener("pointerdown", armFocusGate, { passive: true });
      document.addEventListener("touchstart", armFocusGate, { passive: true });
    
      // Intercept focus attempts
      input.addEventListener("focus", (e) => {
        // If focus wasn't caused by a recent tap, immediately blur so keyboard won't show.
        if (Date.now() > allowFocusUntil) {
          // Delay blur slightly to avoid some Android quirks
          setTimeout(() => input.blur(), 0);
        }
      }, true);
    
      // Optional: if user dismisses keyboard, keep it dismissed until next tap
      // (no extra code needed: gate handles it)
    
    })();
    </script>
                  
</body>
</html>
