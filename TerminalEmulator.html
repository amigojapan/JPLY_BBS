<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C64 Full Screen Simulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
    /* Real C64 colors */
    :root {
        --c64-blue: #352879;
        --c64-lightblue: #706deb;
        --c64-cyan: #6cffee;
        --c64-border: #706deb;
    }

    html, body {
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        image-rendering: pixelated;
    }

    .tv {
        width: 96vw;
        height: 96vh;
        max-width: 1400px;
        border: 20px solid var(--c64-border);
        border-radius: 30px;
        box-shadow:
            0 0 30px rgba(0,0,0,0.9),
            inset 0 0 40px rgba(0,0,0,0.6);
        background: var(--c64-blue);
        padding: 2vh 2vw;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
    }

    #screen {
        flex: 1;
        display: grid;
        grid-template-rows: repeat(25, 1fr);
        grid-template-columns: repeat(40, 1fr);
        gap: 0;
        background: var(--c64-blue);
        color: var(--c64-cyan);
        font-family: 'C64', monospace;
        font-size: clamp(12px, 2.2vh, 36px);
        line-height: 1;
        overflow: auto;
        padding: 1vh 1vw;
        box-sizing: border-box;
    }

    .line {
        grid-column: 1 / -1;
        white-space: pre;
        overflow: hidden;
    }

    .double-wide {
        display: inline-block;
        transform: scaleX(2);
        transform-origin: left center;
        letter-spacing: -0.05em;
    }

    #input-line {
        display: flex;
        align-items: center;
        color: var(--c64-cyan);
    }

    #prompt { margin-right: 0.5ch; }

    #command-input {
        background: transparent;
        border: none;
        outline: none;
        color: var(--c64-cyan);
        font-family: 'C64', monospace;
        font-size: inherit;
        flex: 1;
        caret-color: transparent;
    }

    .cursor {
        display: inline-block;
        width: 1ch;
        background: var(--c64-cyan);
        animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink { to { visibility: hidden; } }

    /* font omitted for brevity in CSS block */
    @font-face {
        font-family: 'C64';
        src: url(data:font/ttf;base64,AAEAAAALAIAAAwAwT1MvMg8SPh0AAAC8AAAAYGNtYXAYVB9VAAABHAAAAFRnYXNwAAAAEAAAA+gAAAAIZ2x5ZlQ1T7AAABAkAAAEKGhlYWQHpD4bAAAANAAAADZoaGVhBnQC8AAAAzgAAAAkaG10eC7q9gAAAEAAAAAUbG9jYQA4AFAAAABsAAAAGm1heHAApgm8AAAA5AAAAAdubWRhBsT+3gAAAOwAAAABAAAAAgAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAQAABdoAAAABAAAAAAAQAAAQAAAAAAAgAABAAAAAAA6AAAAAgABAAAAAAACAAcAAQAAAAAAAwAA ... ) format('truetype');
        font-weight: normal;
        font-style: normal;
    }
</style>
</head>
<body>
<div class="tv">
    <div id="screen"></div>
</div>

<script>
    // Cursor state (column,row). row 0..23 are printable rows, row 24 is input line.
    let cursorX = 0;
    let cursorY = 0; // default to top for boot printing

    const screen = document.getElementById('screen');
    const lines = []; // will hold 25 DOM nodes: rows 0..23 + inputLine at index 24

    // Helper: create a blank printable row element
    function makeRow() {
        const d = document.createElement('div');
        d.className = 'line';
        return d;
    }

    // Build 24 rows
    for (let i = 0; i < 24; i++) {
        const row = makeRow();
        screen.appendChild(row);
        lines.push(row);
    }

    // Input (bottom) line
    const inputLine = makeRow();
    inputLine.id = 'input-line';
    inputLine.innerHTML = `<span id="prompt" class="double-wide">></span><span id="input-text"></span><span class="cursor"> </span>`;
    screen.appendChild(inputLine);
    lines.push(inputLine); // now lines.length === 25

    const inputText = document.getElementById('input-text');

    // Hidden input to capture user typing
    const commandInput = document.createElement('input');
    commandInput.type = 'text';
    commandInput.id = 'command-input';
    document.body.appendChild(commandInput);

    function wide(text) {
        const span = document.createElement('span');
        span.className = 'double-wide';
        span.textContent = text;
        return span;
    }

    // nextLine is now the single place that advances the cursor and scrolls when necessary.
    function nextLine() {
        // Move to column 0 of next row
        cursorX = 0;
        cursorY++;

        // If we passed the last printable row, scroll up
        if (cursorY > 23) {
            // remove top row element
            const removed = lines.shift(); // removes lines[0]
            if (removed && removed !== inputLine) {
                screen.removeChild(removed);
            }
            // create a fresh blank row and insert before inputLine
            const newRow = makeRow();
            screen.insertBefore(newRow, inputLine);
            lines.splice(lines.length - 1, 0, newRow); // insert as last printable row
            // keep cursor at bottom printable row
            cursorY = 23;
        }
    }

    function LOCATE(x, y) {
        // Accept either numbers or strings
        const nx = parseInt(x, 10);
        const ny = parseInt(y, 10);
        cursorX = Number.isNaN(nx) ? 0 : Math.max(0, Math.min(39, nx));
        cursorY = Number.isNaN(ny) ? 0 : Math.max(0, Math.min(23, ny));
    }

    function isPureText(s) {
        return /[^\x00-\x7F]/.test(s) || /^".*"$/.test(s) || /^'.*'$/.test(s);
    }

    // PRINT appends text at current cursor position on the current cursorY row,
    // then advances the cursor via nextLine() (so all newline logic funnels through nextLine()).
    function PRINT(text = '') {
        if (text === null || text === undefined) text = "";
        if (typeof text === 'object') {
            try { text = JSON.stringify(text); }
            catch (e) { text = String(text); }
        } else {
            text = String(text);
        }

        // Find the target row DOM element (cursorY 0..23)
        const targetRow = lines[cursorY];
        if (!targetRow) return;

        // Create span, position it by padding-left (columns)
        const span = wide(text);
        span.style.paddingLeft = `${cursorX}ch`;
        targetRow.appendChild(span);

        // All newlines advance via nextLine()
        nextLine();
    }

    // Keep screen scrolled to bottom visually (optional)
    function scrollToBottom() {
        screen.scrollTop = screen.scrollHeight;
    }

    // Boot messages
    LOCATE(0, 0);
    PRINT("**** JPLY 64 JS_BASIC V1 ****");
    PRINT("");
    PRINT("64K RAM SYSTEM  38911 BASIC BYTES FREE");
    PRINT("");
    PRINT("READY.");
    // Fill to bottom (optional)
    for (let i = 0; i < 17; i++) PRINT("");

    // Input bindings
    commandInput.addEventListener('input', () => {
        inputText.textContent = commandInput.value;
    });

    commandInput.addEventListener('keydown', (e) => {
        if (e.key !== 'Enter') return;
        const raw = commandInput.value.trim();
        const cmd = raw;
        const upper = cmd.toUpperCase();

        // Echo the command on current cursor row (BASIC echoes on input area historically;
        // here we append an echoed line above the input line)
        const echoRow = makeRow();
        echoRow.appendChild(wide('>' + cmd));
        screen.insertBefore(echoRow, inputLine);
        lines.splice(lines.length - 1, 0, echoRow);
        // If we exceeded 25 lines, remove top
        if (lines.length > 25) {
            const removed = lines.shift();
            if (removed && removed !== inputLine) screen.removeChild(removed);
        }

        // Handle commands
        if (cmd) {
            // LOCATE(...) or LOCATE x,y
            if (upper.startsWith("LOCATE(") && cmd.endsWith(")")) {
                const inner = cmd.slice(7, -1);
                const parts = inner.split(",");
                if (parts.length === 2) {
                    LOCATE(parts[0], parts[1]);
                    commandInput.value = '';
                    inputText.textContent = '';
                    commandInput.focus();
                    scrollToBottom();
                    return;
                }
            } else if (upper.startsWith("LOCATE ")) {
                const inner = cmd.slice(7).trim();
                const parts = inner.split(",");
                if (parts.length === 2) {
                    LOCATE(parts[0], parts[1]);
                    commandInput.value = '';
                    inputText.textContent = '';
                    commandInput.focus();
                    scrollToBottom();
                    return;
                }
            }

            // PRINT("...")
            if (upper.startsWith("PRINT(") && cmd.endsWith(")")) {
                let inner = cmd.slice(6, -1).trim();
                inner = inner.replace(/^["']|["']$/g, '');
                PRINT(inner);
            }
            // PRINT ...
            else if (upper.startsWith("PRINT ")) {
                PRINT(cmd.slice(6).trim());
            }
            // Pure text (Japanese etc) -> print literal
            else if (isPureText(cmd)) {
                PRINT(cmd.replace(/^["']|["']$/g, ''));
            }
            // JS fallback
            else {
                try {
                    const result = eval(cmd);
                    if (result !== undefined) PRINT(result);
                } catch (err) {
                    PRINT('?SYNTAX  ERROR');
                }
            }
        }

        // After handling, print READY. (READY. also advances via PRINT -> nextLine)
        PRINT("READY.");
        commandInput.value = '';
        inputText.textContent = '';
        commandInput.focus();
        scrollToBottom();
    });

    // Keep focus on hidden input
    document.addEventListener('click', () => commandInput.focus());
    commandInput.focus();
</script>
</body>
</html>
